<!DOCTYPE html>
<html>

<!--
!!    MOE On-Line Manuals
!!    COPYRIGHT (C) CHEMICAL COMPUTING GROUP ULC.  ALL RIGHTS RESERVED.
!!-->
<head>
  <meta http-equiv="x-ua-compatible" content="IE=9" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../include/manstyle.css" />
  <link rel="icon" type="image/png" href="../../images/ccgicon.png" />
  <link rel="shortcut icon" type="image/png" href="../../images/ccgicon.png" />
  <meta name="keywords" content="keywords:" />
  <meta name="keywords" content="functions: ph4_QueryXxx" />
  <meta name="keywords" content="_functions: ph4_QueryOpen" />
  <meta name="keywords" content="_functions: ph4_QueryClose" />
  <meta name="keywords" content="_functions: ph4_QueryKey" />
  <meta name="keywords" content="_functions: ph4_QueryKeyOpen" />
  <meta name="keywords" content="_functions: ph4_QueryWriteFile" />
  <meta name="keywords" content="_functions: ph4_QueryReadFile" />
  <meta name="keywords" content="_functions: ph4_QueryWriteString" />
  <meta name="keywords" content="_functions: ph4_QueryReadString" />
  <meta name="keywords" content="_functions: ph4_QueryEncode" />
  <meta name="keywords" content="_functions: ph4_QueryDecode" />
  <meta name="keywords" content="_functions: ph4_QueryR64encodeln" />
  <meta name="keywords" content="_functions: ph4_QueryR64decodeln" />
  <meta name="keywords" content="_functions: ph4_SchemeGetBitmaskAll" />
  <meta name="keywords" content="_functions: ph4_SchemeExprProp" />
  <meta name="keywords" content="_functions: ph4_QueryFkeylist" />
  <meta name="keywords" content="_functions: ph4_QueryCkeylist" />
  <meta name="keywords" content="_functions: ph4_QueryVkeylist" />
  <meta name="keywords" content="_functions: ph4_QueryFcount" />
  <meta name="keywords" content="_functions: ph4_QueryCcount" />
  <meta name="keywords" content="_functions: ph4_QueryVcount" />
  <meta name="keywords" content="_functions: ph4_QueryFkeyidx" />
  <meta name="keywords" content="_functions: ph4_QueryCkeyidx" />
  <meta name="keywords" content="_functions: ph4_QueryVkeyidx" />
  <meta name="keywords" content="_functions: ph4_QuerySdata" />
  <meta name="keywords" content="_functions: ph4_QuerySetSdata" />
  <meta name="keywords" content="_functions: ph4_QueryFdata" />
  <meta name="keywords" content="_functions: ph4_QuerySetFdata" />
  <meta name="keywords" content="_functions: ph4_QueryCdata" />
  <meta name="keywords" content="_functions: ph4_QuerySetCdata" />
  <meta name="keywords" content="_functions: ph4_QueryVdata" />
  <meta name="keywords" content="_functions: ph4_QuerySetVdata" />
  <meta name="keywords" content="_functions: ph4_QueryCreateF" />
  <meta name="keywords" content="_functions: ph4_QueryCreateC" />
  <meta name="keywords" content="_functions: ph4_QueryCreateV" />
  <meta name="keywords" content="_functions: ph4_QueryCopyF" />
  <meta name="keywords" content="_functions: ph4_QueryCopyC" />
  <meta name="keywords" content="_functions: ph4_QueryCopyV" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteF" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteC" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteV" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteAllFC" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteAllV" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteAll" />
  <meta name="keywords" content="_functions: ph4_QueryPermuteF" />
  <meta name="keywords" content="_functions: ph4_QueryPermuteC" />
  <meta name="keywords" content="_functions: ph4_QueryPermuteV" />
  <meta name="keywords" content="_functions: ph4_QueryDataErr" />
  <meta name="keywords" content="_functions: ph4_QueryDataOK" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteUselessC" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteUselessV" />
  <meta name="keywords" content="_functions: ph4_QueryDeleteAllIgnored" />
  <meta name="keywords" content="_functions: ph4_QueryCopyCat" />
  <meta name="keywords" content="_functions: ph4_QueryMergeV" />
  <meta name="keywords" content="_functions: ph4_QueryDemergeV" />
  <meta name="keywords" content="_functions: ph4_QuerySoftenAllF" />
  <meta name="keywords" content="_functions: ph4_QuerySoftenV" />
  <title>Ph4 Query API Functions</title>
</head>
<body>
<div class="center-page">
  <!-- START MOE_HEADER -->
  <div class="MOE_HEADER">
    <a href="../../index.htm"><img src="../../images/ccglogo.png" /></a>
    <a href="../../index.htm"><div class="moeversion"></div></a>
    Ph4 Query API Functions
  </div>
<!-- END MOE_HEADER -->
<div class="content">

<h1>Syntax</h1>

<pre class="code">
qkey = <a class="fcnlink" href="#ph4_QueryOpen">ph4_QueryOpen</a> []
qkey = <a class="fcnlink" href="#ph4_QueryOpen">ph4_QueryOpen</a> qkey
<a class="fcnlink" href="#ph4_QueryClose">ph4_QueryClose</a> qkey

qkey = <a class="fcnlink" href="#ph4_QueryKey">ph4_QueryKey</a> qkey
qkey = <a class="fcnlink" href="#ph4_QueryKeyOpen">ph4_QueryKeyOpen</a> qkey

---------- <a href="#I/O_Functions">I/O Functions</a> ----------

<a class="fcnlink" href="#ph4_QueryWriteFile">ph4_QueryWriteFile</a> [qkey, fn]
<a class="fcnlink" href="#ph4_QueryReadFile">ph4_QueryReadFile</a> [qkey, fn]
bstr = <a class="fcnlink" href="#ph4_QueryWriteString">ph4_QueryWriteString</a> qkey
<a class="fcnlink" href="#ph4_QueryReadString">ph4_QueryReadString</a> [qkey, bstr]
bstr = <a class="fcnlink" href="#ph4_QueryEncode">ph4_QueryEncode</a> qkey
<a class="fcnlink" href="#ph4_QueryDecode">ph4_QueryDecode</a> [qkey, bstr]
lines = <a class="fcnlink" href="#ph4_QueryR64encodeln">ph4_QueryR64encodeln</a> qkey
<a class="fcnlink" href="#ph4_QueryR64decodeln">ph4_QueryR64decodeln</a> [qkey, lines]

---------- <a href="#Access_Keys">Access Keys</a> ----------

fkey = <a class="fcnlink" href="#ph4_QueryFkeylist">ph4_QueryFkeylist</a> qkey
ckey = <a class="fcnlink" href="#ph4_QueryCkeylist">ph4_QueryCkeylist</a> qkey
vkey = <a class="fcnlink" href="#ph4_QueryVkeylist">ph4_QueryVkeylist</a> qkey

fcount = <a class="fcnlink" href="#ph4_QueryFcount">ph4_QueryFcount</a> qkey
ccount = <a class="fcnlink" href="#ph4_QueryCcount">ph4_QueryCcount</a> qkey
vcount = <a class="fcnlink" href="#ph4_QueryVcount">ph4_QueryVcount</a> qkey

fidx = <a class="fcnlink" href="#ph4_QueryFkeyidx">ph4_QueryFkeyidx</a> [qkey, fkey]
cidx = <a class="fcnlink" href="#ph4_QueryCkeyidx">ph4_QueryCkeyidx</a> [qkey, ckey]
vidx = <a class="fcnlink" href="#ph4_QueryVkeyidx">ph4_QueryVkeyidx</a> [qkey, vkey]

---------- <a href="#Get/Set_Data_Contents">Get/Set Data Contents</a> ----------

dvals = <a class="fcnlink" href="#ph4_QuerySdata">ph4_QuerySdata</a> [qkey, dnames]
<a class="fcnlink" href="#ph4_QuerySetSdata">ph4_QuerySetSdata</a> [qkey, dnames, dvals]
dvals = <a class="fcnlink" href="#ph4_QuerySetSdata">ph4_QuerySetSdata</a> [qkey, dnames, dvals]

dvals = <a class="fcnlink" href="#ph4_QueryFdata">ph4_QueryFdata</a> [qkey, fkey, dnames]
<a class="fcnlink" href="#ph4_QuerySetFdata">ph4_QuerySetFdata</a> [qkey, fkey, dnames, dvals]
dvals = <a class="fcnlink" href="#ph4_QuerySetFdata">ph4_QuerySetFdata</a> [qkey, fkey, dnames, dvals]

dvals = <a class="fcnlink" href="#ph4_QueryCdata">ph4_QueryCdata</a> [qkey, ckey, dnames]
<a class="fcnlink" href="#ph4_QuerySetCdata">ph4_QuerySetCdata</a> [qkey, ckey, dnames, dvals]
dvals = <a class="fcnlink" href="#ph4_QuerySetCdata">ph4_QuerySetCdata</a> [qkey, ckey, dnames, dvals]

dvals = <a class="fcnlink" href="#ph4_QueryVdata">ph4_QueryVdata</a> [qkey, vkey, dnames]
<a class="fcnlink" href="#ph4_QuerySetVdata">ph4_QuerySetVdata</a> [qkey, vkey, dnames, dvals]
dvals = <a class="fcnlink" href="#ph4_QuerySetVdata">ph4_QuerySetVdata</a> [qkey, vkey, dnames, dvals]

---------- <a href="#Specific_Structural_Changes">Specific Structural Changes</a> ----------

fnewkey = <a class="fcnlink" href="#ph4_QueryCreateF">ph4_QueryCreateF</a> [qkey, fdata]
fnewkey = <a class="fcnlink" href="#ph4_QueryCreateF">ph4_QueryCreateF</a> [qkey, fdata, fdstkey]
cnewkey = <a class="fcnlink" href="#ph4_QueryCreateC">ph4_QueryCreateC</a> [qkey, cdata]
cnewkey = <a class="fcnlink" href="#ph4_QueryCreateC">ph4_QueryCreateC</a> [qkey, cdata, cdstkey]
vnewkey = <a class="fcnlink" href="#ph4_QueryCreateV">ph4_QueryCreateV</a> [qkey, vdata]
vnewkey = <a class="fcnlink" href="#ph4_QueryCreateV">ph4_QueryCreateV</a> [qkey, vdata, vdstkey]

fnewkey = <a class="fcnlink" href="#ph4_QueryCopyF">ph4_QueryCopyF</a> [qkey, fkey]
fnewkey = <a class="fcnlink" href="#ph4_QueryCopyF">ph4_QueryCopyF</a> [qkey, fkey, fdstkey]
cnewkey = <a class="fcnlink" href="#ph4_QueryCopyC">ph4_QueryCopyC</a> [qkey, ckey]
cnewkey = <a class="fcnlink" href="#ph4_QueryCopyC">ph4_QueryCopyC</a> [qkey, ckey, cdstkey]
vnewkey = <a class="fcnlink" href="#ph4_QueryCopyV">ph4_QueryCopyV</a> [qkey, vkey]
vnewkey = <a class="fcnlink" href="#ph4_QueryCopyV">ph4_QueryCopyV</a> [qkey, vkey, vdstkey]

<a class="fcnlink" href="#ph4_QueryDeleteF">ph4_QueryDeleteF</a> [qkey, fkey]
<a class="fcnlink" href="#ph4_QueryDeleteC">ph4_QueryDeleteC</a> [qkey, ckey]
<a class="fcnlink" href="#ph4_QueryDeleteV">ph4_QueryDeleteV</a> [qkey, vkey]

<a class="fcnlink" href="#ph4_QueryPermuteF">ph4_QueryPermuteF</a> [qkey, fsrckey, fdstkey]
<a class="fcnlink" href="#ph4_QueryPermuteC">ph4_QueryPermuteC</a> [qkey, csrckey, cdstkey]
<a class="fcnlink" href="#ph4_QueryPermuteV">ph4_QueryPermuteV</a> [qkey, vsrckey, vdstkey]

---------- <a href="#General_Structural_Utilities">General Structural Utilities</a> ----------

err = <a class="fcnlink" href="#ph4_QueryDataErr">ph4_QueryDataErr</a> qkey
ok  = <a class="fcnlink" href="#ph4_QueryDataOK">ph4_QueryDataOK</a> qkey

<a class="fcnlink" href="#ph4_QueryDeleteAllFC">ph4_QueryDeleteAllFC</a> qkey
<a class="fcnlink" href="#ph4_QueryDeleteAllV">ph4_QueryDeleteAllV</a> qkey
<a class="fcnlink" href="#ph4_QueryDeleteAll">ph4_QueryDeleteAll</a> qkey

<a class="fcnlink" href="#ph4_QueryDeleteUselessC">ph4_QueryDeleteUselessC</a> qkey
<a class="fcnlink" href="#ph4_QueryDeleteUselessV">ph4_QueryDeleteUselessV</a> qkey
<a class="fcnlink" href="#ph4_QueryDeleteAllIgnored">ph4_QueryDeleteAllIgnored</a> qkey

<a class="fcnlink" href="#ph4_QueryCopyCat">ph4_QueryCopyCat</a> [qkey, qkeylist]

---------- <a href="#Examples">Examples</a> ----------

<a class="fcnlink" href="#ph4_QuerySoftenAllF">ph4_QuerySoftenAllF</a> [qkey, fkey, sval]
<a class="fcnlink" href="#ph4_QuerySoftenV">ph4_QuerySoftenV</a> [qkey, vkey, sval]
vnewkey = <a class="fcnlink" href="#ph4_QueryMergeV">ph4_QueryMergeV</a> [qkey, vkey, vdstkey]
vnewkey = <a class="fcnlink" href="#ph4_QueryDemergeV">ph4_QueryDemergeV</a> [qkey, vkey, vdstkey]

---------- <a href="#Additional_Utilities">Additional Utilities</a> ----------

bitmask = <a class="fcnlink" href="#ph4_SchemeGetBitmaskAll">ph4_SchemeGetBitmaskAll</a> [scheme, pnames]
pvals = <a class="fcnlink" href="#ph4_SchemeExprProp">ph4_SchemeExprProp</a> [scheme, expr, pnames, defval]
</pre>


<h1>Description</h1>

<p>Pharmacophore Query API allows SVL callers to create and modify
  pharmacophore queries. The user is <i>not</i> allowed to access any of the
  data structures that store the ph4 query directly and must <i>always</i>
  access them only via the provided API methods. Note that some of the
  &quot;values&quot; are not stored directly but calculated from other items,
  even when the access is read-write.</p>

<p>All code accessing the query should use the following pattern:</p>

<pre class="code">
qkey = ph4_QueryOpen[];
ph4_QueryReadFile [qkey, fn];       // or similar

    ...     access and modify               ...
    ...     features/constraints/volumes    ...

ph4_QueryWriteFile [qkey, fn];      // or similar
ph4_QueryClose qkey;
</pre>

<p>Each feature/constraint/volume item is accessed via its own unique key.
  The list of all keys is returned by functions <tt>ph4_QueryF/C/Vkeylist</tt>.
  The data associated with each item are accessible using functions
  <tt>ph4_QueryF/C/Vdata</tt> and can be modified with functions
  <tt>ph4_QuerySetF/C/Vdata</tt>. For example, to increase the radii of
  essential features by 23%:</p>

<pre class="code">
fkey = ph4_QueryFkeylist;
[m_essential, rad] = ph4_QueryFdata [q, fkey, ['essential','rad']];
ph4_QuerySetFdata [q, fkey | m_essential, ['rad'], [rad * 1.23]];
</pre>

<p>To reorder items, create new items or delete old items, use structural
  utilities, such as <tt>ph4_QueryPermuteF/C/V</tt> or
  <tt>ph4_QueryCreateF/C/V</tt>. For example, to append an excluded sphere
  volume of a given center, <tt>ctr</tt>, and radius, <tt>rad</tt>, and then
  sort volumes by type and delete all ignored volumes:</p>

<pre class="code">
ph4_QueryCreateV [q, [mtype:'None', sphere_center:ctr, sphere_rad:rad]];
vkey = ph4_QueryVkeylist;
[mtype,ignored] = ph4_QueryVdata [q, vkey, ['mtype','ignored']];
ph4_QueryPermuteV [q, vkey, vkey[x_sort mtype]];
ph4_QueryDeleteV [q, vkey | ignored];
</pre>

<p>The query can be duplicated or composed from other queries with
  <tt>ph4_QueryCopyCat</tt>.</p>

<pre class="code">
[nf1, nf2, nf3] = app ph4_QueryFcount [q1, q2, q3];
fkey = ph4_QueryCopyCat [q, [q1,q2,q3]];
[fkey1, fkey2, fkey3] = split [fkey, [nf1, nf2, nf3]];
</pre>
<a id="ph4_QueryOpen"></a>
<hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryOpen</span> []
qkey = <span class="fcndef">ph4_QueryOpen</span> qkey
</pre>

<p>Open a new query context or reopen an existing context. The context will
  be open until the caller task calls ph4_QueryClose or is terminated. If a
  forked task needs to access the same query context, it should reopen its key.
</p>
<a id="ph4_QueryClose"></a>
<hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryClose</span> qkey
</pre>

<p>Close the given query context and release all its resources.</p>
<a id="ph4_QueryKey"></a>
<a id="ph4_QueryKeyOpen"></a>
<hr noshade="noshade" />

<pre>
qkey = <span class="fcndef">ph4_QueryKey</span> qkey
qkey = <span class="fcndef">ph4_QueryKeyOpen</span> qkey
</pre>

<p>Function <tt>ph4_QueryKey</tt> validates the given query key,
  <tt>qkey</tt>. If the key is valid, it is returned as-is. Otherwise, the
  function returns 0.</p>

<p>Function <tt>ph4_QueryKeyOpen</tt> returns the same result as
  <tt>ph4_QueryKey</tt>. However, if the key is valid, function
  <tt>ph4_QueryKeyOpen</tt> additionally opens <tt>qkey</tt>. If the key is
  valid, it is returned as-is. Otherwise, the function returns 0.
  <!-- ********************************************************* --></p>
<a id="I/O_Functions"></a>
<hr noshade="noshade" />

<h2>I/O Functions</h2>
<a id="ph4_QueryWriteFile"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryWriteFile</span> [qkey, fn]
</pre>

<p>Function <tt>ph4_QueryWriteFile</tt> writes query to a file or a
  filehandle in a printable format that can be processed by non-SVL programs,
  but is not as efficient as the <tt>ph4_QueryEncode/Decode</tt> internal SVL
  format.</p>
<a id="ph4_QueryReadFile"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryReadFile</span> [qkey, fn]
</pre>

<p>Function <tt>ph4_QueryReadFile</tt> reads query from a file or a
  filehandle. The current contents of the query is replaced (without
  warning).</p>
<a id="ph4_QueryWriteString"></a>
<hr noshade="noshade" />

<pre>
bstr = <span class="fcndef">ph4_QueryWriteString</span> qkey
</pre>

<p>Function <tt>ph4_QueryWriteString</tt> writes query to a string, using the
  same format as <tt>ph4_QueryWriteFile</tt>.</p>
<a id="ph4_QueryReadString"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryReadString</span> [qkey, bstr]
</pre>

<p>Function <tt>ph4_QueryReadString</tt> reads query from a string, using the
  same format as <tt>ph4_QueryReadFile</tt>. The current contents of the query
  is replaced.</p>
<a id="ph4_QueryEncode"></a>
<hr noshade="noshade" />

<pre>
bstr = <span class="fcndef">ph4_QueryEncode</span> qkey
</pre>

<p>Function <tt>ph4_QueryEncode</tt> writes query to a string of bytes using
  an efficient internal format suitable to be sent through a socket or get
  embedded in a binary file. The contents of the string is meant to be
  processed only by SVL.</p>
<a id="ph4_QueryDecode"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDecode</span> [qkey, bstr]
</pre>

<p>Function <tt>ph4_QueryDecode</tt> reads query from a string of bytes
  encoded by <tt>ph4_QueryEncode</tt>. The current contents of the query is
  replaced.</p>
<a id="ph4_QueryR64encodeln"></a>
<hr noshade="noshade" />

<pre>
lines = <span class="fcndef">ph4_QueryR64encodeln</span> qkey
</pre>

<p>Function <tt>ph4_QueryR64encode</tt> writes query to a vector of printable
  lines suitable to be embedded in a text file. The contents of the lines is
  meant to be read only by SVL.</p>
<a id="ph4_QueryR64decodeln"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryR64decodeln</span> [qkey, lines]
</pre>

<p>Function <tt>ph4_QueryR64decode</tt> reads query from a vector of strings
  (lines) encoded by <tt>ph4_QueryR64encode</tt>. The current contents of the
  query is replaced.
  <!-- ********************************************************* --></p>
<a id="Access_Keys"></a>
<hr noshade="noshade" />

<h2>Access Keys</h2>

<p>Each feature/constraint/volume is accessed via its own unique key. The
  keys are returned by functions <tt>ph4_Query<i>X</i>keylist</tt>, where
  <tt><i>X</i></tt>=<tt>F,C,V</tt>.</p>

<p>Each key is guaranteed to be unique across the entire MOE/cluster
  (MOE/smp) for the lifetime of the application, but stays valid only until the
  query is closed. If the query is opened and restored, e.g. by reading it from
  a file, its feature/constraint/volume keys will change. However, their
  relative positions, returned by functions <tt>ph4_Query<i>X</i>keyidx</tt>,
  will stay intact.</p>
<a id="ph4_QueryFkeylist"></a>
<hr noshade="noshade" />

<pre>
fkey = <span class="fcndef">ph4_QueryFkeylist</span> qkey
</pre>

<p>Function <tt>ph4_QueryFkeylist</tt> returns keys of all features in the
  query.</p>
<a id="ph4_QueryCkeylist"></a>
<hr noshade="noshade" />

<pre>
ckeys = <span class="fcndef">ph4_QueryCkeylist</span> qkey
</pre>

<p>Function <tt>ph4_QueryCkeylist</tt> returns keys of all constraints in the
  query.</p>
<a id="ph4_QueryVkeylist"></a>
<hr noshade="noshade" />

<pre>
vkeys = <span class="fcndef">ph4_QueryVkeylist</span> qkey
</pre>

<p>Function <tt>ph4_QueryVkeylist</tt> returns keys of all volumes in the
  query.</p>
<a id="ph4_QueryFcount"></a>
<hr noshade="noshade" />

<pre>
fcount = <span class="fcndef">ph4_QueryFcount</span> qkey
</pre>

<p>Function <tt>ph4_QueryFcount</tt> returns the number of all features in
  the query.</p>
<a id="ph4_QueryCcount"></a>
<hr noshade="noshade" />

<pre>
ccount = <span class="fcndef">ph4_QueryCcount</span> qkey
</pre>

<p>Function <tt>ph4_QueryCcount</tt> returns the number of all constraints in
  the query.</p>
<a id="ph4_QueryVcount"></a>
<hr noshade="noshade" />

<pre>
vcount = <span class="fcndef">ph4_QueryVcount</span> qkey
</pre>

<p>Function <tt>ph4_QueryVcount</tt> returns the number of all volumes in the
  query.</p>
<a id="ph4_QueryFkeyidx"></a>
<hr noshade="noshade" />

<pre>
fidx = <span class="fcndef">ph4_QueryFkeyidx</span> [qkey, fkey]
</pre>

<p>Function <tt>ph4_QueryFkeyidx</tt> returns, for each key, the position of
  the corresponding feature in the query. The function is a <i>unop</i> in the
  <tt>fkey</tt> argument.</p>
<a id="ph4_QueryCkeyidx"></a>
<hr noshade="noshade" />

<pre>
cidx = <span class="fcndef">ph4_QueryCkeyidx</span> [qkey, ckey]
</pre>

<p>Function <tt>ph4_QueryCkeyidx</tt> returns, for each key, the position of
  the corresponding constraint in the query. The function is a <i>unop</i> in
  the <tt>ckey</tt> argument.</p>
<a id="ph4_QueryVkeyidx"></a>
<hr noshade="noshade" />

<pre>
vidx = <span class="fcndef">ph4_QueryVkeyidx</span> [qkey, vkey]
</pre>

<p>Function <tt>ph4_QueryVkeyidx</tt> returns, for each key, the position of
  the corresponding volume in the query. The function is a <i>unop</i> in the
  <tt>vkey</tt> argument.
  <!-- ********************************************************* --></p>
<a id="Get/Set_Data_Contents"></a>
<hr noshade="noshade" />

<h2>Get/Set Data Contents</h2>

<p>Each feature/constraint/volume is described by a number of parameters. The
  functions that access and modify these parameters are called
  <tt>ph4_Query<i>X</i>data</tt> and <tt>ph4_QuerySet<i>X</i>data</tt>, where
  <tt><i>X</i></tt>=<tt>F,C,V,</tt>. Each function must be given a set of keys
  to affect, <tt>fkey/ckey/vkey</tt>, and a set of parameter names,
  <tt>dnames</tt>. Given a set of <i>n</i> keys and <i>m</i> parameter names,
  each function gets or sets <i>n</i>&times;<i>m</i> values. Values of unknown
  parameters names are set to <tt>[]</tt>.</p>

<p>The positions and radii of features and volumes are rounded to the nearest
  1/1000 angstrom.</p>

<p>Optionally, each set-function can also return the values of the set
  parameters to the caller. These values may sometimes differ from the input
  arguments, e.g. when values of type <tt>'pos'</tt> or
  <tt>'rad'</tt> are rounded or when values of type
  <tt>'idx'</tt> contain duplicates and must be adjusted.</p>

<p>Some parameter types, e.g. <tt>'sphere_count'</tt> are
  <i>read-only</i> and cannot be set.</p>
<a id="ph4_QuerySdata"></a>
<a id="ph4_QuerySetSdata"></a>
<hr noshade="noshade" />

<pre>
dvals = <span class="fcndef">ph4_QuerySdata</span> [qkey, dnames]
<span class="fcndef">ph4_QuerySetSdata</span> [qkey, dnames, dvals]
dvals = <span class="fcndef">ph4_QuerySetSdata</span> [qkey, dnames, dvals]
</pre>

<p>Function <tt>ph4_QuerySdata</tt> returns, for each name in
  <tt>dnames</tt>, the value associated with that name.</p>

<p>Function <tt>ph4_QuerySetSdata</tt> sets, for each name in
  <tt>dnames</tt>, the value associated with that name. If the return value is
  requested, the function returns the actual set values. (In this function, the
  set values are identical to the input values.)</p>

<p>Functions <tt>ph4_QuerySdata</tt> and <tt>ph4_QuerySetSdata</tt> support
  the following <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="quarter"><tt>'scheme'</tt></td>
    <td>Scheme name (token).</td>
  </tr>
  <tr>
    <td><tt>'msize_min'</tt></td>
    <td>Minimum match size (integer). Zero is interpreted
    &quot;all&quot;. Negative value is interpreted as &quot;all
    except&quot;.</td>
  </tr>
  <tr>
    <td><tt>'title'</tt></td>
    <td>Single-line title visible in ph4 edit and search
    panels. The value is a token scalar.</td>
  </tr>
  <tr>
    <td><tt>'comment'</tt></td>
    <td>Multi-line description of the contents of the ph4
    query. The value is a flat vector of characters.</td>
  </tr>
  <tr>
    <td><i>unknown</i></td>
    <td>Empty vector (<tt>[]</tt>).</td>
  </tr>
</table>
<!-- EndArgTable -->
<a id="ph4_QueryFdata"></a>
<a id="ph4_QuerySetFdata"></a>
<hr noshade="noshade" />

<pre>
dvals = <span class="fcndef">ph4_QueryFdata</span> [qkey, fkey, dnames]
<span class="fcndef">ph4_QuerySetFdata</span> [qkey, fkey, dnames, dvals]
dvals = <span class=
"fcndef">ph4_QuerySetFdata</span> [qkey, fkey, dnames, dvals]
</pre>

<p>Function <tt>ph4_QueryFdata</tt> returns, for each name in
  <tt>dnames</tt>, a vector of values associated with that name. The values are
  retrieved only from features specified by the vector of keys, <tt>fkey</tt>.
  The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i> vectors,
  <i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>, with each vector composed
  of <i>m</i> elements, <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;fkey</tt>.</p>

<p>The function is a <i>unop</i> in the <tt>fkey</tt> argument. For example,
  if keys <tt>f1</tt>, <tt>f2</tt>, <tt>f3</tt> refer to features with the
  following values:</p>

<pre class="code">
f1 ::= [expr:'Acc', rad:1.1];
f2 ::= [expr:'Cat', rad:1.2];
f3 ::= [expr:'Don', rad:1.3];
... </pre>

<p>then</p>

<pre class="code oneline">
r = ph4_QueryFdata [q, [f1, [f2, f3, ...]], ['expr', 'rad']];
</pre>

<p>will return</p>

<pre class="code oneline">
r = [['Acc', ['Cat', 'Don', ...]], [1.1, [1.2, 1.3, ...]]]
</pre>

<p>Function <tt>ph4_QuerySetFdata</tt> sets, for each name in
  <tt>dnames</tt>, the value associated with that name. If the return value is
  requested, the function returns the actual set values. Note that the set
  values may differ from the input values, e.g. when the input positions or
  radii are rounded to the nearest 1/1000 angstrom or when the input
  <tt>'idx'</tt> values contain duplicates.</p>

<p>The function is a <i>unop</i> in the <tt>fkey</tt> argument. The
  <tt>dvals</tt> argument must be of the same length as <tt>dnames</tt>. Each
  <tt>dvals(i)</tt> will unit-extend to the shape of <tt>fkey</tt>. For
  example, if</p>

<pre class="code">
e = ['Acc', ['Don']];
r = [1.1];
</pre>

<p>then</p>

<pre class="code oneline">
ph4_QuerySetFdata [q, [f1, [f2, f3, ...]], ['expr', 'rad'], [e, r]];
</pre>

<p>will reset the feature values to:</p>

<pre class="code">
f1 ::= [expr:'Acc', rad:1.1, ...];
f2 ::= [expr:'Don', rad:1.1, ...];
f3 ::= [expr:'Don', rad:1.1, ...];
...
</pre>

<p>Functions <tt>ph4_QueryFdata</tt> and <tt>ph4_QuerySetFdata</tt> support
  the following <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'idx'</tt></td>
    <td>Position of the feature in the list of all
    features.</td>
  </tr>
  <tr>
    <td><tt>'ignored'</tt></td>
    <td>Set to 1 on features that will <i>not</i> be
    matched by the ph4 search.</td>
  </tr>
  <tr>
    <td><tt>'essential'</tt></td>
    <td>Set to 1 on features that <i>must</i> be matched
    by the ph4 search.</td>
  </tr>
  <tr>
    <td><tt>'expr'</tt></td>
    <td>Matching expression, e.g. <tt>'Don&amp;Acc |
    Cat'</tt>.</td>
  </tr>
  <tr>
    <td><tt>'pos'</tt></td>
    <td>Feature position, rounded to the nearest 1/1000
    angstrom.</td>
  </tr>
  <tr>
    <td><tt>'rad'</tt></td>
    <td>Feature size, rounded to the nearest 1/1000
    angstrom.</td>
  </tr>
  <tr>
    <td><tt>'color'</tt></td>
    <td>RGB color of features shown in the 3D window by
    the ph4 editor.</td>
  </tr>
  <tr>
    <td><tt>'hidden'</tt></td>
    <td>Set to 1 on features that will not be shown in
    the 3D window by the ph4 editor.</td>
  </tr>
  <tr>
    <td><i>unknown</i></td>
    <td>Empty vector (<tt>[]</tt>).</td>
  </tr>
</table><!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryFdata</tt> supports the following
  (read-only) <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'ckeys'</tt></td>
    <td>Keys of constraints that affect the feature.</td>
  </tr>
  <tr>
    <td><tt>'expr_AtomQ'</tt></td>
    <td>Any annotation point that can match the feature
    is heavy-atom-based.</td>
  </tr>
  <tr>
    <td><tt>'expr_Projected'</tt></td>
    <td>Any annotation point that can match the feature
    is a projected point.</td>
  </tr>
  <tr>
    <td><tt>'expr_Projecting'</tt></td>
    <td>Any annotation point that can match the feature
    is a projecting point.</td>
  </tr>
  <tr>
    <td><tt>'expr_OK'</tt></td>
    <td>Set to 1 on features whose expression (including
    SMARTS, if any) is syntactically valid.</td>
  </tr>
  <tr>
    <td><tt>'expr_Err'</tt></td>
    <td>The error message of syntactically invalid
    feature expressions, or empty token otherwise.</td>
  </tr>
</table><!-- EndArgTable -->

<p><i>Note:</i> The value of the <tt>expr_Xxx</tt> properties above depends
  on the scheme used.</p>
<a id="ph4_QueryCdata"></a>
<a id="ph4_QuerySetCdata"></a>
<hr noshade="noshade" />

<pre>
dvals = <span class="fcndef">ph4_QueryCdata</span> [qkey, ckey, dnames]
<span class="fcndef">ph4_QuerySetCdata</span> [qkey, ckey, dnames, dvals]
dvals = <span class=
"fcndef">ph4_QuerySetCdata</span> [qkey, ckey, dnames, dvals]
</pre>

<p>Function <tt>ph4_QueryCdata</tt> returns, for each name in
  <tt>dnames</tt>, a vector of values associated with that name. The values are
  retrieved only from constraints specified by the vector of keys,
  <tt>ckey</tt>. The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i>
  vectors, <i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>, with each vector
  composed of <i>m</i> elements,
  <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;ckey</tt>.</p>

<p>The function is a <i>unop</i> in the <tt>ckey</tt> argument.</p>

<p>Function <tt>ph4_QuerySetCdata</tt> sets, for each name in
  <tt>dnames</tt>, the value associated with that name. If the return value is
  requested, the function returns the actual set values. Note that the set
  values may differ from the input values, e.g. when the input
  <tt>'idx'</tt> values contain duplicates.</p>

<p>The function is a <i>unop</i> in the <tt>ckey</tt> argument. The dvals
  argument must be of the same length as <tt>dnames</tt>. Each
  <tt>dvals(i)</tt> will unit-extend to the shape of <tt>ckey</tt>.</p>

<p>Functions <tt>ph4_QueryCdata</tt> and <tt>ph4_QuerySetCdata</tt> support
  the following <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'idx'</tt></td>
    <td>Position of the constraint in the list of all
    constraints.</td>
  </tr>
  <tr>
    <td><tt>'ignored'</tt></td>
    <td>Set to 1 on features that will <i>not</i> be
    matched by the ph4 search.</td>
  </tr>
  <tr>
    <td><tt>'expr'</tt></td>
    <td>Constraint expression, e.g.
    <tt>'&gt;1'</tt> or <tt>'SameA'</tt>. (See
    <i>Constraint Type</i> below.)</td>
  </tr>
  <tr>
    <td><tt>'fkeys'</tt></td>
    <td>Keys of constrained features.</td>
  </tr>
  <tr>
    <td><i>unknown</i></td>
    <td>Empty vector (<tt>[]</tt>).</td>
  </tr>
</table>
    <!-- EndArgTable -->

<p><i>Constraint Type:</i> The <tt>dval</tt> values of parameter
  <tt>'expr'</tt> specify the condition that the constrained features
  must satisfy in order for the query to be accepted by the ph4 search. Valid
  values include the following: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'0'</tt></td>
    <td>Match either all or none of the specified
    features.</td>
  </tr>
  <tr>
    <td><tt>'=1','=2'</tt></td>
    <td>Match at exactly <i>n</i> of the specified
    features, <i>n</i> = 1, 2.</td>
  </tr>
  <tr>
    <td>
    <tt>'&gt;1'</tt>,<tt>'&gt;2'</tt>,
    <tt>'&gt;3'</tt>,<tt>'&gt;4'</tt>,
    <tt>'&gt;5'</tt></td>
    <td>Match at least <i>n</i> of the specified
    features, <i>n</i> = 1, 2, 3, 4, 5.</td>
  </tr>
  <tr>
    <td><tt>'SameA'</tt></td>
    <td>Matched features must use the same defining atom
    or the same set of defining atoms.</td>
  </tr>
  <tr>
    <td><tt>'ShareA'</tt></td>
    <td>Matched features must share some of their
    defining atoms: their sets of defining atoms must intersect.</td>
  </tr>
</table>
<!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryFdata</tt> supports the following
  (read-only) <tt>dnames</tt> value: <!-- ArgTable --></p>

<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>fcount</tt></td>
    <td>The number of constrained features.</td>
  </tr>
</table>
    <!-- EndArgTable -->
<a id="ph4_QueryVdata"></a>
<a id="ph4_QuerySetVdata"></a>
<hr noshade="noshade" />

<pre>
dvals = <span class="fcndef">ph4_QueryVdata</span> [qkey, vkey, dnames]
<span class="fcndef">ph4_QuerySetVdata</span> [qkey, vkey, dnames, dvals]
dvals = <span class=
"fcndef">ph4_QuerySetVdata</span> [qkey, vkey, dnames, dvals]
</pre>

<p>Function <tt>ph4_QueryVdata</tt> returns, for each name in
  <tt>dnames</tt>, a vector of values associated with that name. The values are
  retrieved only from volumes specified by the vector of keys, <tt>vkey</tt>.
  The result is an <i>n</i>&times;<i>m</i> matrix of <i>n</i> vectors,
  <i>n</i>&nbsp;=&nbsp;<tt>length&nbsp;dnames</tt>, with each vector composed
  of <i>m</i> elements, <i>m</i>&nbsp;=&nbsp;<tt>length&nbsp;vkey</tt>.</p>

<p>The function is a <i>unop</i> in the <tt>vkey</tt> argument.</p>

<p><tt>ph4_QuerySetVdata</tt> sets, for each name in <tt>dnames</tt>, the
  value associated with that name. If the return value is requested, the
  function returns the actual set values. Note that the set values may differ
  from the input values, e.g. when the input positions or radii are rounded to
  the nearest 1/1000 angstrom or when the input <tt>'idx'</tt> values
  contain duplicates.</p>

<p>The function is a <i>unop</i> in the <tt>vkey</tt> argument. The dvals
  argument must be of the same length as <tt>dnames</tt>. Each
  <tt>dvals(i)</tt> will unit-extend to the shape of <tt>vkey</tt>.</p>

<p>Functions <tt>ph4_QueryVdata</tt> and <tt>ph4_QuerySetVdata</tt> support
  the following <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'idx'</tt></td>
    <td>Position of the volume in the list of all
    volumes.</td>
  </tr>
  <tr>
    <td><tt>'ignored'</tt></td>
    <td>Set to 1 on volumes that will be ignored by the
    ph4 search.</td>
  </tr>
  <tr>
    <td><tt>'expr'</tt></td>
    <td>SMARTS expression; <tt>''</tt> means
    <i>any heavy atom</i>.</td>
  </tr>
  <tr>
    <td><tt>'mtype'</tt></td>
    <td>Atom match type. (See <i>Volume Match Type</i>
    below.)</td>
  </tr>
  <tr>
    <td><tt>'gtype'</tt></td>
    <td>Volume geometry. (See <i>Volume Geometry</i>
    below.)</td>
  </tr>
  <tr>
    <td><tt>'pos'</tt></td>
    <td>Position. In volumes of <tt>gtype</tt>
    <tt>'SphereUnion'</tt>, it is the centroid of all spheres.</td>
  </tr>
  <tr>
    <td><tt>'rad'</tt></td>
    <td>Size. In volumes of <tt>gtype</tt>
    <tt>'SphereUnion'</tt>, it is the radius of the largest
    sphere.</td>
  </tr>
  <tr>
    <td><tt>'sphere_center'</tt></td>
    <td>Laminated xyz coordinates of centers of all
    spheres that comprise volumes of type <tt>'SphereUnion'</tt>.
    Set to <tt>[]</tt> otherwise.</td>
  </tr>
  <tr>
    <td><tt>'sphere_rad'</tt></td>
    <td>Radii of all spheres that comprise volumes of
    type <tt>'SphereUnion'</tt>. Set to <tt>[]</tt> otherwise.</td>
  </tr>
  <tr>
    <td><tt>'color'</tt></td>
    <td>RGB color of volumes shown in the 3D window by
    the ph4 editor.</td>
  </tr>
  <tr>
    <td><tt>'hidden'</tt></td>
    <td>Set to 1 on volumes that will not be shown in the
    3D window by the ph4 editor.</td>
  </tr>
  <tr>
    <td><i>unknown</i></td>
    <td>Empty vector (<tt>[]</tt>).</td>
  </tr>
</table>
<!-- EndArgTable -->

<p>Additionally, the function <tt>ph4_QueryVdata</tt> supports the following
  (read-only) <tt>dnames</tt> values: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'sphere_count'</tt></td>
    <td>The number of spheres comprising the volume of
    type <tt>'SphereUnion'</tt>. Set to 0 otherwise.</td>
  </tr>
  <tr>
    <td><tt>'expr_OK'</tt></td>
    <td>Set to 1 on volumes whose expression (i.e. the
    SMARTS string) is syntactically valid.</td>
  </tr>
  <tr>
    <td><tt>'expr_Err'</tt></td>
    <td>The error message of syntactically invalid volume
    expressions, or empty token otherwise.</td>
  </tr>
</table><!-- EndArgTable -->

<p><i>Volume Match Type:</i> The <tt>dval</tt> values of parameter
  <tt>'mtype'</tt> specify how the atoms that match the volume
  expression are interpreted by the ph4 search: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'None'</tt></td>
    <td>&quot;Excluded&quot; volume: no matched atoms
    allowed in the interior.</td>
  </tr>
  <tr>
    <td><tt>'Some'</tt></td>
    <td>&quot;Included&quot; volume: some matched atoms
    must be in the interior</td>
  </tr>
  <tr>
    <td><tt>'All'</tt></td>
    <td>&quot;Exterior&quot; volume: all matched atoms
    must be in the interior</td>
  </tr>
</table><!-- EndArgTable -->

<p><i>Volume Geometry:</i> The <tt>dval</tt> values of parameter
  <tt>'gtype'</tt> specify the volume geometry. Currently, there is
  only one possible value: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td class="width-quarter"><tt>'SphereUnion'</tt></td>
    <td>A single sphere or a union of several
    spheres.</td>
  </tr>
</table><!-- EndArgTable -->
  <!-- ********************************************************* -->
<a id="Specific_Structural_Changes"></a>
<hr noshade="noshade" />

<h2>Specific Structural Changes</h2>

<p>Functions in this chapter can be used to create, duplicate, delete or
  permute specified features/constraints/volumes of the query.</p>

<p><i>Destination Keys:</i> Some of the functions use a vector of
  <i>destination keys</i>, <tt>fdstkey/cdstkey/vdstkey</tt>, to specify the
  destination positions of the new/duplicated/moved
  features/constraints/volumes. Two additional, non-key values can be used in
  this argument: <!-- ArgTable --></p>
<table class="noborder width-75p">
  <tr>
    <td>0</td>
    <td>The positions before the first item.</td>
  </tr>
  <tr>
    <td><i>Inf</i></td>
    <td>The positions after the last item.</td>
  </tr>
</table>
<!-- EndArgTable -->

<p>If the vector of destination keys is shorter that the number of items that
  must be positioned, the remaining items are appended after the last
  destination position specified. If the vector of destination keys is empty,
  all items are appended at the end.</p>
<a id="ph4_QueryCreateF"></a>
<a id="ph4_QueryCreateC"></a>
<a id="ph4_QueryCreateV"></a>
<hr noshade="noshade" />

<pre>
fnewkey = <span class="fcndef">ph4_QueryCreateF</span> [qkey, fdata]
fnewkey = <span class="fcndef">ph4_QueryCreateF</span> [qkey, fdata, fdstkey]

cnewkey = <span class="fcndef">ph4_QueryCreateC</span> [qkey, cdata]
cnewkey = <span class="fcndef">ph4_QueryCreateC</span> [qkey, cdata, cdstkey]

vnewkey = <span class="fcndef">ph4_QueryCreateV</span> [qkey, vdata]
vnewkey = <span class="fcndef">ph4_QueryCreateV</span> [qkey, vdata, vdstkey]
</pre>

<p>Function <tt>ph4_QueryCreate<i>X</i></tt>,
  <tt><i>X</i></tt>=<tt>F,C,V</tt>, appends <i>n</i> new
  features/constraints/volumes, with the contents of the <tt>i</tt>-th new
  feature specified by a tagvector <tt><i>x</i>data(i)</tt>,
  <tt><i>x</i></tt>=<tt>f,c,v</tt>, <tt>i</tt>=1..<i>n</i>. The tagvector needs
  to specify only values that different from their new-feature default,
  e.g.</p>

<pre class="code">[pos:[3.1,5,1.2],&nbsp;rad:1.2]</pre>

<p>The optional vector of destination keys, <tt>fdstkey/cdstkey/vdstkey</tt>,
  specifies the destination positions of the new features. (See <i>Destination
  Keys</i> above for the interpretation of the destination keys). If the return
  value is requested, the function returns the (new) keys of the created
  features.</p>
<a id="ph4_QueryCopyF"></a>
<a id="ph4_QueryCopyC"></a>
<a id="ph4_QueryCopyV"></a>
<hr noshade="noshade" />

<pre>
fnewkey = <span class="fcndef">ph4_QueryCopyF</span> [qkey, fkey]
fnewkey = <span class="fcndef">ph4_QueryCopyF</span> [qkey, fkey, fdstkey]

fnewkey = <span class="fcndef">ph4_QueryCopyC</span> [qkey, ckey]
fnewkey = <span class="fcndef">ph4_QueryCopyC</span> [qkey, ckey, cdstkey]

fnewkey = <span class="fcndef">ph4_QueryCopyV</span> [qkey, vkey]
fnewkey = <span class="fcndef">ph4_QueryCopyV</span> [qkey, vkey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryCopy<i>X</i></tt>, <tt><i>X</i></tt>=<tt>F,C,V</tt>,
  appends <i>n</i> new features/constraints/volumes that duplicate items
  specified by keys <tt><i>x</i>key(i)</tt>, <tt><i>x</i></tt>=<tt>f,c,v</tt>,
  <tt>i</tt>=1..<i>n</i>. The optional vector of destination keys,
  <tt>fdstkey/cdstkey/vdstkey</tt>, specifies the destination positions of the
  new features. (See note <i>Destination Keys</i> above for the interpretation
  of the destination keys). Each duplicate receives a new key. If the return
  value is requested, the function returns the (new) keys of the created
  features.</p>

<p><i>Note:</i> When features are duplicated, the (new) duplicates will
  <i>not</i> be automatically constrained by the constraints that affect the
  original features. To do add the new features to the old constraints,
  use:</p>

<pre class="code">
ckey = ph4_QueryCkeylist q;
[_fkeys_] = ph4_QueryCdata [q, ckey, 'fkeys'];
_fkeys_ = apt cat [_fkeys_, [newfkey] || _fkeys_ == [fkey]];
ph4_QuerySetCdata [q, ckey, 'fkeys', [_fkeys_]];
</pre>
<a id="ph4_QueryDeleteF"></a>
<a id="ph4_QueryDeleteC"></a>
<a id="ph4_QueryDeleteV"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDeleteF</span> [qkey, fkey]
<span class="fcndef">ph4_QueryDeleteC</span> [qkey, ckey]
<span class="fcndef">ph4_QueryDeleteV</span> [qkey, vkey]
</pre>

<p>Function <tt>ph4_QueryDelete<i>X</i></tt>,
  <tt><i>X</i></tt>=<tt>F,C,V</tt>, deletes <i>n</i>
  features/constraints/volumes specified by keys <tt><i>x</i>key(i)</tt>,
  <tt><i>x</i></tt>=<tt>f,c,v</tt>, <tt>i</tt>=1..<i>n</i>.</p>

<p><i>Note:</i> When features are deleted, the constraints that, as a result,
  become empty will <i>not</i> be automatically deleted.</p>

<p><i>Note:</i> Unlike other <tt>ph4_QueryXxx</tt> functions that accept
  keys, <tt>ph4_QueryDelete<i>X</i></tt> functions do <i>not</i> report an
  error when given an illegal key value.</p>

<p><i>Example:</i> To delete all ignored features:</p>

<pre class="code">
[m_i] = ph4_QueryFdata [q, fkey, ['ignored']];
ph4_QueryDeleteF [q, fkey | m_i];
</pre>

<p><i>Example:</i> To delete all empty constraints:</p>

<pre class="code">
[c] = ph4_QueryCdata [q, ckey, ['fcount']];
ph4_QueryDeleteC [q, ckey | c==0];
</pre>

<p><i>Example:</i> To delete all empty excluded volumes:</p>

<pre class="code">
[g,m,c] = ph4_QueryVdata [q, vkey, ['gtype', 'mtype', 'sphere_count']];
ph4_QueryDeleteV [q, vkey | g=='SphereUnion' and m=='None' and c==0];
</pre>
<a id="ph4_QueryPermuteF"></a>
<a id="ph4_QueryPermuteC"></a>
<a id="ph4_QueryPermuteV"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryPermuteF</span> [qkey, fsrckey, fdstkey]
<span class="fcndef">ph4_QueryPermuteC</span> [qkey, csrckey, cdstkey]
<span class="fcndef">ph4_QueryPermuteV</span> [qkey, vsrckey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryPermute<i>X</i></tt>,
  <tt><i>X</i></tt>=<tt>F,C,V</tt>, permutes the order of features specified by
  a vector of unique keys, <tt><i>x</i>srckey</tt>,
  <tt><i>x</i></tt>=<tt>f,c,v</tt>. The permutation is specified by a vector of
  the same (unique) keys, given in their desired new order,
  <tt><i>x</i>dstkey</tt>.
  <!-- ********************************************************* --></p>
<a id="General_Structural_Utilities"></a>
<hr noshade="noshade" />

<h2>General Structural Utilities</h2>

<p>Functions in this chapter affect or modify the entire query. There is not
  specification of features/constraints/volumes of the query to be
  affected.</p>
<a id="ph4_QueryDataErr"></a>
<a id="ph4_QueryDataOK"></a>
<hr noshade="noshade" />

<pre>
err = <span class="fcndef">ph4_QueryDataErr</span> qkey
ok  = <span class="fcndef">ph4_QueryDataOK</span> qkey
</pre>

<p>Function <tt>ph4_QueryDataError</tt> determines whether the given query
  can be used by the ph4 search without generating errors. If no errors are
  detected, the function returns an empty token (<tt>''</tt>).
  Otherwise, the function returns a single token containing the first error
  found.</p>

<p>Function <tt>ph4_QueryDataOK</tt> simply returns 0 on error and 1
  otherwise.</p>

<p><i>Note</i>: Since the validity of some parameters depends on the value of
  other parameters, which may change (e.g. the validity of feature expressions
  depends on the value of the scheme parameter), it is not enough for each
  individual <tt>ph4_QuerySetF/C/Vdata</tt> call to succeed: the validity of
  the query should checked with <tt>ph4_QueryDataOK</tt> at such a time when
  the query values will no longer change.</p>

<p><i>Warning</i>: The function <tt>ph4_QueryDataOK</tt> assumes that the
  query has been generated by valid API calls. The function checks only for
  errors that can arise by an illegal combination of otherwise legal values. If
  the query has been modified by other means, e.g. by directly accessing the
  underlying structures, the function will not return a correct answer.</p>
<a id="ph4_QueryDeleteAllFC"></a>
<a id="ph4_QueryDeleteAllV"></a>
<a id="ph4_QueryDeleteAll"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDeleteAllFC</span> qkey
<span class="fcndef">ph4_QueryDeleteAllV</span> qkey
<span class="fcndef">ph4_QueryDeleteAll</span> qkey
</pre>

<p>Function <tt>ph4_QueryDeleteAllFC</tt> deletes all features and
  constraints in the query.</p>

<p>Function <tt>ph4_QueryDeleteAllV</tt> deletes all volumes in the
  query.</p>

<p>Function <tt>ph4_QueryDeleteAll</tt> deletes all features, constraints and
  volumes in the query.</p>
<a id="ph4_QueryDeleteUselessC"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDeleteUselessC</span> qkey
</pre>

<p>Function <tt>ph4_QueryDeleteUselessC</tt> deletes all empty or otherwise
  useless constraints. Ignored constraints that are not empty are <i>not</i>
  deleted.</p>
<a id="ph4_QueryDeleteUselessV"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDeleteUselessV</span> qkey
</pre>

<p>Function <tt>ph4_QueryDeleteUselessV</tt> deletes all useless volumes,
  such as a union of empty excluded spheres. Ignored volumes that are not empty
  are <tt>not</tt> deleted.</p>
<a id="ph4_QueryDeleteAllIgnored"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryDeleteAllIgnored</span> qkey
</pre>

<p>Function <tt>ph4_QueryDeleteAllIgnored</tt> deletes all ignored or useless
  features, constraints and volumes.</p>
<a id="ph4_QueryCopyCat"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QueryCopyCat</span> [qkey, qkeylist]
</pre>

<p>Function <tt>ph4_QueryCopyCat</tt> replaces the given query,
  <tt>qkey</tt>, with the concatenated contents of a list of queries,
  <tt>qkeylist</tt>. Each <tt>qkeylist(i)</tt> must be a valid query key.
  However, the list may contain duplicates and/or the replaced query,
  <tt>qkey</tt>, itself. All queries in <tt>qkeylist</tt> <i>must</i> use the
  same scheme. The match size of the result will be set to the added match
  sizes of the combined queries, keeping the sign of the match size of
  <tt>qkeylist(1)</tt>. For example, if <tt>qkeylist</tt> contains two queries,
  one with <tt>msize_min</tt>=-2 and the other with <tt>msize_min</tt>=-3, then
  the match size of the concatenated query, <tt>qkey</tt>, will be set to
  <tt>msize_min</tt>=-5.</p>

<p><i>Note</i>: All keys in <tt>qkey</tt> will change, even when the query is
  copied to itself, i.e.</p>

<pre class="code">ph4_QueryCopyCat&nbsp;[qkey, qkey]</pre>

<p>Constraints of duplicated queries will <i>not</i> be merged.
  <!-- ********************************************************* --></p>
<a id="Examples"></a>
<hr noshade="noshade" />

<h2>Examples</h2>

<p>The following utilities can serve as examples of using the Ph4 Query API
  functions. They manipulate the input query only via calls to API
  functions.</p>
<a id="ph4_QuerySoftenAllF"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QuerySoftenAllF</span> [qkey, sval]
</pre>

<p>Function <tt>ph4_QuerySoftenAllF</tt> makes the query features easier
  (<tt>sval</tt>&gt;0) or harder (<tt>sval</tt>&lt;0) to match by increasing or
  decreasing the feature radii. The <tt>sval</tt> argument specifies the
  percentage by which the radii should be increased or decreased.</p>

<p><i>Note</i>: To modify the feature radii, a multiplicative (not additive)
  factor must be used to keep the relative weight of matched features
  intact.</p>

<pre class="code">
local function soften_f [r, s] = r * maxE [1, 1+s] * invz maxE [1, 1-s];

global function ph4_QuerySoftenAllF [q, sval]
    local fkey = ph4_QueryFkeylist q;
    local [rad] = ph4_QueryFdata [q, fkey, ['rad']];
    ph4_QuerySetFdata [q, fkey, ['rad'], [soften_f [rad, sval]]];
endfunction
</pre>
<a id="ph4_QuerySoftenV"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">ph4_QuerySoftenV</span> [qkey, vkey, sval]
</pre>

<p>Function <tt>ph4_QuerySoftenV</tt> makes the query volumes easier
  (<tt>sval</tt> &gt; 0) or harder (<tt>sval</tt> &lt; 0) to match by
  increasing/decreasing the volume sizes. The <tt>sval</tt> argument specifies,
  in angstroms, an additive increment or decrement of the radii, except for
  very small radii.</p>

<p><i>Note</i>: To modify the volume radii, which can be large and differ
  significantly from each other, an additive factor is more appropriate than
  the multiplicative factor used for the feature radii. The formula has been
  designed so that if the volumes are softened by <tt>sval</tt> and then
  (de_softened again by the opposite value (<tt>-sval</tt>), they will return
  to their original size (except for rounding errors.)</p>

<pre class="code">
local function soften_v [r, s]
    local m2 = s &gt; 0 and r &lt;= 1;  // small radii grow as a percentage
    local m3 = s &lt;= 0 and r+s &lt;= 1;       // small radii shrink as a percentage
    local m1 = not m2 and not m3;       // big radii grow/shrink as an offset

    if alltrue m1 then return r+s; endif        // no small radii
    return (r+s*m1) * (1+s*m2) * invz (1-s*m3); // need a binop (not select)
endfunction

global function ph4_QuerySoftenV [q, vkey, sval]
    local [gtype, mtype] = ph4_QueryVdata [q, vkey, ['gtype', 'mtype']];
    [vkey, mtype] = [vkey, mtype] || [gtype == 'SphereUnion'];  // safety
    local [rad] = ph4_QueryVdata [q, vkey, ['sphere_rad']];
    rad = soften_v [rad, sgn [sval, mtype &lt;&gt; 'None']];
    ph4_QuerySetVdata [q, vkey, ['sphere_rad'], [rad]];
endfunction
</pre>
<a id="ph4_QueryMergeV"></a>
<hr noshade="noshade" />

<pre>
vnewkey = <span class="fcndef">ph4_QueryMergeV</span> [qkey, vkey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryMergeV</tt> merges several volumes (of compatible
  types) into one. The input volumes, specified by <tt>vkey</tt>, are destroyed
  and a new volume is created in their place. The position of the new volume in
  the list of all volumes is specified by <tt>vdstkey</tt>. The function
  returns the key of the created volume. If the volumes can't be merged,
  the function returns 0.</p>

<p><i>Note</i>: If the function succeeds and returns non-0, the input keys,
  <tt>vkey</tt>, will become invalid.</p>

<pre class="code">
global function ph4_QueryMergeV [q, vkey, vdstkey]

        // Verify that the supplied volumes are all of the same mtype
        // (e.g. 'None'=excluded volume) and of gtype 'SphereUnion'
        // (even though, currently, there is no other gtype value.)

    local [gtype, mtype] = ph4_QueryVdata [q, vkey, ['gtype','mtype']];
    if neL mtype then return 0; endif
    if neL cat [gtype, 'SphereUnion'] then return 0; endif
    if isnull vkey then return 0; endif
    vkey = uniq vkey;           // allow, but ignore duplicates

        // Create a new volume as a copy of the first volume provided,
        // vkey(1), optionally positioned in the list of all volumes
        // after the volume vdstkey.

    local newvkey = ph4_QueryCopyV [q, vkey(1), vdstkey];

        // Extract the (laminated) centers and radii of the volumes
        // to be merged and delete the volumes.

    local CR = ['sphere_center', 'sphere_rad'];
    local [c, r] = ph4_QueryVdata [q, vkey, CR];
    ph4_QueryDeleteV [q, vkey];

        // Insert the concatenated centers and radii into the new volume.

    ph4_QuerySetVdata [q, newvkey, CR, app nest [[apt cat c], [cat r]]];

    return newvkey;
endfunction
</pre>
<a id="ph4_QueryDemergeV"></a>
<hr noshade="noshade" />

<pre>
vnewkey = <span class="fcndef">ph4_QueryDemergeV</span> [qkey, vkey, vdstkey]
</pre>

<p>Function <tt>ph4_QueryDemergeV</tt> demerges one or more volumes into
  several single-sphere volumes of the same type. The input volumes are
  destroyed and new volumes are created in their place. The function returns
  the keys of the created volumes. If the volumes can't be demerged, the
  function returns 0.</p>

<p><i>Note</i>: If the function succeeds and returns non-0, the input keys,
  <tt>vkey</tt>, will become invalid.</p>

<pre class="code">
global function ph4_QueryDemergeV [q, vkey, vdstkey]

        // Verify that the volumes can be demerged. (Currently, always ok.)

    local [gtype] = ph4_QueryVdata [q, vkey, ['gtype']];
    if neL cat [gtype, 'SphereUnion'] then return 0; endif
    if isnull vkey then return []; endif        // nothing to demerge
    vkey = uniq vkey;                   // allow, but ignore duplicates

        // Collect the centers and radii of spheres from the volumes
        // and flatten them.  NOTE: The total number of spheres to be
        // created is &quot;add v_n&quot;.

    local CR = ['sphere_center', 'sphere_rad'];
    local [v_n, v_c, v_r] = ph4_QueryVdata [q, vkey, cat ['sphere_count', CR]];
    v_c = cat app tr v_c;               // a list of all centers
    v_r = cat v_r;                      // a flat list of all radii

        // Create new volume to hold individual spheres from the old volume.
        // Each new volume inherits properties of the corresponding old
        // volume (accomplished by duplicating volumes &quot;stretch [vkey, v_n]&quot;).

    local newvkey = ph4_QueryCopyV [q, stretch [vkey, v_n], vdstkey];
    ph4_QuerySetVdata [q, newvkey, CR, [v_c, v_r]];
    ph4_QueryDeleteV [q, vkey];

    return newvkey;
endfunction
</pre>
  <!-- ********************************************************* -->
<a id="Additional_Utilities"></a>
<hr noshade="noshade" />

<h2>Additional Utilities</h2>
<a id="ph4_SchemeGetBitmaskAll"></a>
<pre>
bitmask = <span class="fcndef">ph4_SchemeGetBitmaskAll</span> [scheme, pnames]
</pre>

<p>Function <tt>ph4_SchemeGetBitmaskAll</tt> returns, for each property name,
  <tt>pname(i)</tt>, the bitmask of all scheme bits that satisfy the given
  property. <!-- The supported property names include 'AtomQ', 'NonAtomQ',
'Centroid' 'Projected', 'Projecting' and 'Hydrophobic'. -->
   An annotation point has the given property (e.g.
  &quot;heavy-atom-based&quot;) if at least one bit associated with the point
  is of that type. For each property whose name is not recognized the function
  returns -1.</p>

<p>The supported values of <tt>pname(i)</tt> include: <!-- ArgTable --></p>
<table class="noborder">
  <tr>
    <td><tt>'AtomQ'</tt></td>
    <td>Any annotation point that can match the feature
    is heavy-atom-based.</td>
  </tr>
  <tr>
    <td><tt>'Projected'</tt></td>
    <td>Any annotation point that can match the feature
    is a projected point.</td>
  </tr>
  <tr>
    <td><tt>'Projecting'</tt></td>
    <td>Any annotation point that can match the feature
    is a projecting point.</td>
  </tr>
  <tr>
    <td><em>unknown</em></td>
    <td>Set to -1.</td>
  </tr>
</table>
    <!-- EndArgTable -->
<a id="ph4_SchemeExprProp"></a>
<hr noshade="noshade" />

<pre>
pvals = <span class="fcndef">ph4_SchemeExprProp</span> [scheme, expr, pnames, defval]
</pre>

<p>Function <tt>ph4_SchemeExprProp</tt> calculates properties of a list of
  expressions, <tt>expr</tt>. The function returns a matrix of values,
  <tt>M</tt>, where <tt>M(i)(j)</tt> is the value of property <tt>pname(i)</tt>
  in the expression <tt>expr(j)</tt>.</p>

<p>The function supports the following values to be used as the property
  name, <tt>pname(i)</tt>: <!-- ArgTable --></p>
<table class="noborder">
  <tr>
    <td><tt>'OK'</tt></td>
    <td>Expression will not cause an error.</td>
  </tr>
  <tr>
    <td><tt>'Err'</tt></td>
    <td>Error message reported by an expression (empty
    token when no error).</td>
  </tr>
  <tr>
    <td><tt>'AtomQ'</tt></td>
    <td>Any annotation point that can match the feature
    is heavy-atom-based.</td>
  </tr>
  <tr>
    <td><tt>'Projected'</tt></td>
    <td>Any annotation point that can match the feature
    is a projected point.</td>
  </tr>
  <tr>
    <td><tt>'Projecting'</tt></td>
    <td>Any annotation point that can match the feature
    is a projecting point.</td>
  </tr>
  <tr>
    <td><em>unknown</em></td>
    <td>The value of <tt>defval(i)</tt>.</td>
  </tr>
</table>
<!-- EndArgTable -->

<p>When the property value, <tt>pname(i)</tt> is <i>unknown</i>, i.e. not
  recognized, the returned valued is set to <tt>defval(i)</tt>. The
  <tt>defval</tt> argument is optional; if <tt>defval</tt> is missing (or
  empty), <tt>defval(i)</tt> is set to 0. If <tt>defval</tt> is non-empty, it
  unit extends.</p>

<p><b>Example.</b> Given a list feature expressions, <tt>expr</tt>, the
  following code sets <tt>m_atomic</tt> to the mask of all atom-based
  features:</p>

<pre class="code">
[m_atomic] = ph4_SchemeExprProp [scheme, expr, 'AtomQ'];
</pre>
  <!-- START MOE_FOOTER -->
  <div class="MOE_FOOTER">
    <img src="../../images/ccgicon.png" /> <a href="../../index.htm"></a>
    <a href="../../legal.htm"></a> &copy;<span class="versionyear"></span>
    <a href="http://www.chemcomp.com"></a>. All rights reserved.<br />
    <a href="mailto:info@chemcomp.com"></a>
  </div><!-- END MOE_FOOTER -->
</div>
</div>
</body>
</html>

