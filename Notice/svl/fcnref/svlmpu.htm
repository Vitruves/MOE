<!DOCTYPE html>
<html>

<!--
!!    MOE On-Line Manuals
!!    COPYRIGHT (C) CHEMICAL COMPUTING GROUP ULC.  ALL RIGHTS RESERVED.
!!-->
<head>
  <meta http-equiv="x-ua-compatible" content="IE=9" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../include/manstyle.css" />
  <link rel="icon" type="image/png" href="../../images/ccgicon.png" />
  <link rel="shortcut icon" type="image/png" href="../../images/ccgicon.png" />
  <meta name="keywords" content="keywords:" />
  <meta name="keywords" content="functions: MPU_HOSTCOUNT" />
  <meta name="keywords" content="functions: MPU_PORTCOUNT" />
  <meta name="keywords" content="functions: MPU_THISHOST" />
  <meta name="keywords" content="functions: MPU_HOSTNAMES" />
  <meta name="keywords" content="functions: MPU_DIGITBITS" />
  <meta name="keywords" content="functions: MPU_DIGITCOUNT" />
  <meta name="keywords" content="functions: MPU_NEIGHBORS" />
  <meta name="keywords" content="functions: mpu_batch" />
  <meta name="keywords" content="functions: mpu_call" />
  <meta name="keywords" content="functions: mpu_eval" />
  <meta name="keywords" content="functions: mpu_load" />
  <meta name="keywords" content="functions: mpu_run" />
  <meta name="keywords" content="functions: mpu_script" />
  <meta name="keywords" content="functions: mpu_portalloc" />
  <meta name="keywords" content="functions: mpu_portfree" />
  <meta name="keywords" content="functions: mpu_send" />
  <meta name="keywords" content="functions: mpu_receive" />
  <meta name="keywords" content="functions: mpu_reply" />
  <meta name="keywords" content="functions: mpu_cprint" />
  <meta name="keywords" content="functions: mpu_print" />
  <meta name="keywords" content="functions: mpu_cwrite" />
  <meta name="keywords" content="functions: mpu_write" />
  <meta name="keywords" content="functions: mpu_charencode" />
  <meta name="keywords" content="functions: mpu_chardecode" />
  <meta name="keywords" content="functions: SVL_MPU_PASSWORD" />
  <meta name="keywords" content="functions: SVL_MPU_USER" />
  <meta name="keywords" content="functions: mpu_password" />
  <meta name="keywords" content="functions: mpu_distance" />
  <title>SVL Multi-Processor Functions</title>
</head>
<body>
<div class="center-page">
  <!-- START MOE_HEADER -->
  <div class="MOE_HEADER">
    <a href="../../index.htm"><img src="../../images/ccglogo.png" /></a>
    <a href="../../index.htm"><div class="moeversion"></div></a>
    SVL Multi-Processor Functions
  </div>
<!-- END MOE_HEADER -->
<div class="content">

<h1>Syntax</h1>

<pre class="code">
<a class="fcnlink" href="#MPU_HOSTCOUNT">MPU_HOSTCOUNT</a>
<a class="fcnlink" href="#MPU_PORTCOUNT">MPU_PORTCOUNT</a>
<a class="fcnlink" href="#MPU_THISHOST">MPU_THISHOST</a>

<a class="fcnlink" href="#MPU_HOSTNAMES">MPU_HOSTNAMES</a>

<a class="fcnlink" href="#MPU_DIGITBITS">MPU_DIGITBITS</a>
<a class="fcnlink" href="#MPU_DIGITCOUNT">MPU_DIGITCOUNT</a>
<a class="fcnlink" href="#MPU_NEIGHBORS">MPU_NEIGHBORS</a>

<a class="fcnlink" href="#mpu_print">mpu_print</a> expr
<a class="fcnlink" href="#mpu_cprint">mpu_cprint</a> expr
<a class="fcnlink" href=
"#mpu_write">mpu_write</a> [&#39;format&#39;, arg1, arg2, ...]
<a class="fcnlink" href=
"#mpu_cwrite">mpu_cwrite</a> [&#39;format&#39;, arg1, arg2, ...]

[result,code,seqno,udata] = <a class="fcnlink" href=
"#mpu_batch">mpu_batch</a>  [ cmd, arg1, arg2, udata ]

[result,code] = <a class="fcnlink" href=
"#mpu_call">mpu_call</a>   [ host, fcn, arg, file ]
[result,code] = <a class="fcnlink" href=
"#mpu_eval">mpu_eval</a>   [ host, expr, arg ]
[result,code] = <a class="fcnlink" href=
"#mpu_load">mpu_load</a>   [ host, src ]
[result,code] = <a class="fcnlink" href=
"#mpu_run">mpu_run</a>    [ host, src, arg, fcn ]
[result,code] = <a class="fcnlink" href=
"#mpu_script">mpu_script</a> [ host, src, arg ]

port = <a class="fcnlink" href="#mpu_portalloc">mpu_portalloc</a> []
<a class="fcnlink" href="#mpu_portfree">mpu_portfree</a> port

reply = <a class="fcnlink" href=
"#mpu_send">mpu_send</a> [receiver_port, msg, reply_port]
reply = <a class="fcnlink" href=
"#mpu_send">mpu_send</a> [receiver_port, msg, reply_port, timeout]
[reply_port, msg] = <a class="fcnlink" href=
"#mpu_receive">mpu_receive</a> receiver_port
[reply_port, msg] = <a class="fcnlink" href=
"#mpu_receive">mpu_receive</a> [receiver_port, timeout]
<a class="fcnlink" href="#mpu_reply">mpu_reply</a> [reply_port, reply_msg]

char_data = <a class="fcnlink" href=
"#mpu_charencode">mpu_charencode</a> value
value     = <a class="fcnlink" href=
"#mpu_chardecode">mpu_chardecode</a> char_data

scrambled_token = <a class="fcnlink" href=
"#mpu_password">mpu_password</a> password_token
n_hops = <a class="fcnlink" href=
"#mpu_distance">mpu_distance</a> [hostA, hostB]
</pre>

<h1>Description</h1>

<p><b>Distributed computing.</b> An N-node multi-processor is comprised of N
  mutually connected instances of the SVL execution environment. The number of
  processors, N, is stored in the SVL constant <tt>MPU_HOSTCOUNT</tt>. Each
  processor, or <i>host</i>, is assigned a <i>host number</i>, an integer from
  1 to <tt>MPU_HOSTCOUNT</tt>. Each host stores its host number in the SVL
  constant <tt>MPU_THISHOST</tt>.</p>

<p>SVL multi-processor environment is controlled by functions and constants
  whose names are prefixed by <tt>mpu_</tt> or <tt>MPU_</tt>. For many
  applications, the only multi-processor function needed is the function
  <tt>mpu_batch</tt>, which automatically handles distribution of jobs and
  collection of results (and/or errors). Explicit distribution of jobs is
  accomplished with <tt>mpu_call</tt> and related functions. Explicit transfer
  of data between hosts is accomplished with functions
  <tt>mpu_send/receive/reply</tt>.</p>

<p><b>Command line.</b> The application command line switches <tt>-mpu</tt>
  and <tt>-mpulog</tt> are used on application startup to define and monitor a
  multi-processor session. For example, a Unix application called <tt>pgm</tt>
  using an SVL multi-processor would use the command line switches as
  follows:</p>

<pre class="code">
user% pgm -mpu machinefile -mpulog logfile
</pre>

<p>The configuration file, <tt>machinefile</tt>, identifies hosts of the
  multi-processor. The report file, <tt>logfile</tt>, contains information
  about the multi-processor startup and the errors detected during the
  execution. The <tt>logfile</tt> is intended for troubleshooting and is
  generally not used.</p>

<p>If <tt>machinefile</tt> is a dash (<tt>-</tt>), then the configuration is
  read from the process&#39; standard input stream (<tt>stdin</tt>). If
  <tt>logfile</tt> is a dash (<tt>-</tt>), then the output text is written to
  the process&#39; standard error stream (<tt>stderr</tt>).</p>

<p>The simplest way to start a multi-processor application on a single
  computer is to use the <tt>-mpu&nbsp;N</tt> command line switch. For example
  to start a 2-node multi-processor, use:</p>

<pre class="code">
user% pgm -mpu 2
</pre>

<p>On a network, the <tt>-mpu&nbsp;machinefile</tt> form must be used.</p>

<p><b>Configuration file.</b> The configuration file, <tt>machinefile</tt>,
  is a text file that identifies network computers that will serve as hosts of
  the multi-processor; an SVL processor will be started on each such computer.
  The initiating computer must be identified first - by its name or its IP
  address or simply as <tt>localhost</tt> - and will serve as the root host,
  with host number 1.</p>

<p>The configuration file uses a line-based format. Empty lines or lines that
  start with &quot;<tt>#</tt>&quot; are ignored. Each configuration line may be
  one of:</p>
  <dl>
    <dt><tt>$mpu-user</tt> <i>username</i></dt>
    <dd>Defines the login user account under which multi-processor processes
    will run. The user must exist on the destination machine. If this line does
    not appear in the machine file then the contents of the environment
    variable <tt>SVL_MPU_USER</tt> will be used. If this variable does not
    exist then the <tt>USER</tt> environment variable will be used. If this
    variable does not exist then the contents of the environment variable
    <tt>USERNAME</tt> will be used. If this does not exist then the string
    <tt>nobody</tt> is used. Note: if an environment variable is used then it
    is that of the first processor only; other processors will receive a copy
    of the first processor&#39;s environment variable.</dd>
    <dt><tt>$mpu-password</tt> <i>scrambledpassword</i></dt>
    <dd>Defines the password to use on login to network machines. This must be
    the password of <tt>$mpu-user</tt> (above). For security reasons, the value
    of the password is not plain text but scrambled. The SVL function
    <tt>mpu_password</tt> must be used to compute scrambled passwords from
    plain text. If this line does not appear in the machine file then the
    contents of the environment variable <tt>SVL_MPU_PASSWORD</tt> will be
    used. If this variable does not exist then the empty string. Note: if an
    environment variable is used then it is that of the first processor only;
    other processors will receive a copy of the first processor&#39;s
    environment variable.</dd>
    <dt><tt>$mpu-rexec</tt> <i>shellcommand</i></dt>
    <dd>Defines the default command to execute on each host computer. This
    default can be over-ridden for particular hosts (see below). In general, it
    is best to use a generic host/OS-independent command. Environment variables
    will be expanded locally (on each host separately). The shell command must
    specify <tt>-mpu -</tt> as a command line switch.</dd>
    <dt><tt>$mpu-timeout</tt> <i>k</i></dt>
    <dd>Defines the maximum number of seconds that the multi-processor is given
    to initialize. If the time expires each processor will exit with an error.
    The multi-processor is started in tree fashion and the amount of time given
    for initialization is approximately <i>k</i>&nbsp;log&nbsp;<i>n</i> seconds
    where <i>n</i> is the number of processors (log base 2). The default value
    for <i>k</i> is 10.</dd>
    <dt><tt>$mpu-digitbits</tt> <i>k</i></dt>
    <dd>Defines the base of the multi-processor connection network. The base is
    defined as <i>b</i>&nbsp;=&nbsp;2<sup><i>k</i></sup>. Each host will
    connect to (<i>b</i>-1)&nbsp;ceil&nbsp;log<sub><i>b</i></sub>&nbsp;<i>n</i>
    host where <i>n</i> is the total number of hosts. The default for <i>k</i>
    is 2; the maximum legal value is 10 and the minimum is 1. Larger values
    will allow more efficiency in message routing at the expense of more
    operating system communication resources for each host. On some systems
    (e.g., Windows) communications resources are quite limited.</dd>
    <dt><i>IP</i> &nbsp; <i>shellcommand</i></dt>
    <dd>Lines that do not start with a <tt>$</tt> or <tt>#</tt> are treated as
    <i>host lines</i>. Each host line consists of an IP address (of the form
    a.b.c.d) or a hostname (e.g., myhost@company.com) followed by the shell
    command to be used on the host computer. This shell command overrides the
    <tt>$mpu-rexec</tt> default. If nothing is specified for the shell command
    then the value specified with <tt>$mpu-rexec</tt> is used. The shell
    command must specify <tt>-mpu -</tt> as a command line switch.</dd>
    <dt><tt>$eof</tt></dt>
    <dd>Marks the end of the file. Lines past the <tt>$eof</tt> will not be
    read. If the <tt>$eof</tt> line is not present then the entire file will be
    processed.</dd>
  </dl>

<p>The following is an example of an 8-processor configuration file using a
  base 2 network to run <tt>pgm</tt> under the account of <tt>someuser</tt> on
  several machines.</p>

<pre class="code">
$mpu-user someuser
$mpu-password albcmnjgdaohandamkcilgjofaihjjlnbcpipigkgmnhgp
$mpu-digitbits 2
$mpu-rexec pgm -mpu -
192.1.1.1
192.1.1.2
192.1.1.3
192.1.1.4
192.1.1.5
192.1.1.6
192.1.1.7
192.1.1.8
$eof
</pre>

<p>The <tt>$mpu-rexec</tt> lines specifies that <tt>pgm -mpu -</tt> defines
  the remote command for all processors. (The <tt>-mpu -</tt> part of the
  command is compulsory.)</p>

<p><b>Warning!</b> The SVL multi-processor system requires the <tt>rexec</tt>
  or <tt>ssh</tt> remote execution protocol to launch remote executables;
  therefore, at least one of these protocols must be installed and running on
  each processor specified in the machine file. In the case of <tt>rexec</tt>,
  be aware that not all <tt>rexecd</tt> daemon implementations are complete.
  The GNU <tt>rexecd</tt> is complete.</p>
<a id="MPU_PORTCOUNT"></a>
<a id="MPU_HOSTCOUNT"></a>
<a id="MPU_THISHOST"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">MPU_THISHOST</span>
<span class="fcndef">MPU_HOSTCOUNT</span>
<span class="fcndef">MPU_PORTCOUNT</span>
</pre>

<p>Constant <tt>MPU_THISHOST</tt> stores the host number of the executing
  host. The host number is an integer ranging in value from 1 to the number of
  hosts, stored in the constant <tt>MPU_HOSTCOUNT</tt>. Constant
  <tt>MPU_PORTCOUNT</tt> stores the maximum number of communication ports (used
  by functions <tt>mpu_send/receive/reply</tt>) that can be allocated at the
  same time.</p>
<a id="MPU_HOSTNAMES"></a>
<hr noshade="noshade" />

<pre>
<span class="fcndef">MPU_HOSTNAMES</span>
</pre>

<p>Constant <tt>MPU_HOSTNAMES</tt> stores the names of all hosts of the
  multiprocessor. <tt>MPU_HOSTNAMES(K)</tt> stores the value of the (local)
  constant <tt>HOSTNAME</tt> on host <tt>K</tt>. When all hosts of the SVL
  multi-processor are part of the same machine, the expression</p>

<pre class="code">
eqL MPU_HOSTNAMES
</pre>

<p>will evaluate to non-zero.</p>
<a id="mpu_cprint"></a>
<a id="mpu_print"></a>
<hr noshade="noshade" />

<pre><span class="fcndef">mpu_print</span> expr
<span class="fcndef">mpu_cprint</span> expr
</pre>

<p>Function <tt>mpu_print</tt> will print the result of a given expression on
  the console of the root host, no matter which host called the function. The
  printed value is prefixed by the host number of the caller. The function is
  intended primarily for testing and debugging purposes. Similarly to function
  <tt>pr</tt>, when <tt>mpu_print</tt> is used in an expression, it both prints
  and returns its argument.</p>

<p>For example, on a 3-node multi-processor,</p>

<pre class="code">
svl&gt; mpu_eval [igen MPU_HOSTCOUNT, &#39;mpu_print [host: MPU_THISHOST]&#39;];
</pre>

<p>will cause the following messages to be printed (not necessarily in this
  order) on the console of host #1:</p>

<pre class="code">
#1: [ host:1 ]
#2: [ host:2 ]
#3: [ host:3 ]
</pre>

<p>Function <tt>mpu_cprint</tt> provides two additional features useful in
  the debugging of applications on a small number of hosts: 1) messages from
  different hosts are indented by different amounts of leading white space and
  2) consecutive messages from the same host will appear consecutive on the
  console of host #1, uninterrupted by messages from other hosts.</p>
<a id="mpu_cwrite"></a>
<a id="mpu_write"></a>
<hr noshade="noshade" />

<pre><span class=
  "fcndef">mpu_write</span> [&#39;format&#39;, arg1, arg2, ...]
<span class="fcndef">mpu_cwrite</span> [&#39;format&#39;, arg1, arg2, ...]
</pre>

<p>Similarly to function <tt>mpu_print</tt>, functions <tt>mpu_write</tt> and
  <tt>mpu_cwrite</tt> will print the formatted message on the console of the
  root host, prefixed by the host number of the caller. The syntax of both
  functions is identical to the syntax of function <tt>write</tt>.</p>

<p>For example, on a 3-node multi-processor,</p>

<pre class="code">
svl&gt; mpu_eval [igen MPU_HOSTCOUNT, &#39;mpu_write [\&#39;host={}\\n\&#39;, MPU_THISHOST]&#39;]
</pre>

<p>will cause the following messages to be printed (not necessarily in this
  order) on the console of host #1:</p>

<pre class="code">
#1: host=1
#2: host=2
#3: host=3
</pre>

<p>Function <tt>mpu_cwrite</tt> provides two additional features useful in
  debugging of applications on a small number of hosts: 1) messages from
  different hosts are indented by different amounts of leading white space and
  2) consecutive messages from the same host will appear consecutive on the
  console of host #1, uninterrupted by messages from other hosts.
  <!-- ============================  mpu_batch ============================  -->
</p>
<a id="mpu_batch"></a>
<hr noshade="noshade" />

<pre>[result,code,seqno,udata] = <span class=
  "fcndef">mpu_batch</span> [cmd, arg1, arg2, udata]
</pre>

<p>For most applications, <tt>mpu_batch</tt> is the only multi-processor
  function needed. The <tt>mpu_batch</tt> function automatically handles
  distribution of jobs and collection of results (and/or errors). The function
  is to be called iteratively for many items of data. In each call, the
  function find the next available multi-processor host and send its input data
  to that host for evaluation. At the same time, the function retrieves the
  result from a host that has already finished evaluating data from some of the
  previous calls and returns that result to the caller.</p>

<p>The first <tt>MPU_HOSTCOUNT</tt> items will be sent to the next available
  host without waiting for a result. The last <tt>MPU_HOSTCOUNT</tt> calls will
  only wait for the result from the remote hosts without passing any new items
  for evaluation. The end of the evaluation is signaled to the caller by
  <tt>mpu_batch</tt> returning the <tt>eof</tt> result code (with no result
  data). Therefore, to evaluate <tt>N</tt> data items, the function will be
  called <tt>N+MPU_HOSTCOUNT+1</tt> times.</p>

<p>The first three arguments (<tt>cmd</tt>, <tt>arg1</tt>, <tt>arg2</tt>)
  specify what is to be done on the next available host:</p>
  <table class="titlebar">
    <tr>
      <th><tt>cmd</tt></th>
      <th>Description</th>
    </tr>
    <tr>
      <td><tt>&#39;&#39;</tt></td>
      <td>If the empty token is given as a command then no calculations will be
      started. <tt>mpu_batch</tt> will wait for any outstanding calculations to
      complete. <tt>arg1</tt>, <tt>arg2</tt> and <tt>udata</tt> are ignored.
      After <tt>mpu_batch</tt> is called with a non-empty command for all input
      data items, it must be called another <tt>MPU_HOSTCOUNT+1</tt> times with
      the empty command (<tt>&#39;&#39;</tt>) to retrieve the
      <tt>MPU_HOSTCOUNT</tt> outstanding results from all of the remote hosts
      and, when all results are retrieved, the <tt>eof</tt> result code.
      </td>
    </tr>
    <tr>
      <td><tt>&#39;call&#39;</tt></td>
      <td>The SVL expression <tt>call[arg1,arg2]</tt> will be executed on the
      next available host. Its result will be returned by some of the
      subsequent calls to <tt>mpu_batch</tt>. <tt>arg1</tt> must be a token
      containing the name of a global function defined on all of the hosts and
      <tt>arg2</tt> the argument that will be given to the function.</td>
    </tr>
    <tr>
      <td><tt>&#39;eval&#39;</tt></td>
      <td>The SVL expression <tt>eval[arg1,arg2]</tt> will be executed on the
      next available host. Its result will be returned by some of the
      subsequent calls to <tt>mpu_batch</tt>. <tt>arg1</tt> must be a token or
      string containing the expression to evaluate and <tt>arg2</tt> is
      ignored.</td>
    </tr>
    <tr>
      <td><tt>&#39;load&#39;</tt></td>
      <td>The SVL expression <tt>load[arg1]</tt> will be executed on the next
      available host. Its result will be returned by some of the subsequent
      calls to <tt>mpu_batch</tt>. If <tt>arg1</tt> is a token, then it is
      taken to be a filename of an SVL source file to be loaded. The file must
      be accessible on all remote hosts. If <tt>arg1</tt> is a string, then it
      is taken to be the entire source code of the SVL program to be loaded.
      <tt>arg2</tt> is ignored.</td>
    </tr>
    <tr>
      <td><tt>&#39;run&#39;</tt></td>
      <td>The SVL expression <tt>run[arg1,arg2]</tt> will be executed on the
      next available host. Its result will be returned by some of the
      subsequent calls to <tt>mpu_batch</tt>. If <tt>arg1</tt> is a token, then
      it is taken to be a filename of an SVL source file to be run. The file
      must be accessible on all remote hosts. If <tt>arg1</tt> is a string,
      then it is taken to be the entire source code of the SVL program to be
      run. <tt>arg2</tt> is the argument given to the main function of the
      program run.</td>
    </tr>
    <tr>
      <td><tt>&#39;script&#39;</tt></td>
      <td>The SVL expression <tt>script[arg1,arg2]</tt> will be executed on the
      next available host. Its result will be returned by some of the
      subsequent calls to <tt>mpu_batch</tt>. If <tt>arg1</tt> is a token, then
      it is taken to be a filename of an SVL script file. The file must be
      accessible on all remote hosts. If <tt>arg1</tt> is a string, then it is
      taken to be the entire source code of the SVL script to be executed.
      <tt>arg2</tt> is the argument given to the script.</td>
    </tr>
  </table>

<p>The <tt>udata</tt> argument is a &quot;user data&quot; argument. It is a
  value that will be returned in the <tt>udata</tt> return value when the
  results are ready but is otherwise not interpreted. The <tt>udata</tt> is
  useful for identifying the results when they are ready.</p>

<p>The return values of <tt>mpu_batch</tt> are the results of the remote
  asynchronous calculations. The <tt>code</tt> indicates the nature of the
  result:</p>
  <table class="noborder">
    <tr>
      <th><tt>Code</tt></th>
      <th>Description</th>
    </tr>
    <tr>
      <td><tt>&#39;skip&#39;</tt></td>
      <td>This is the result code for the first <tt>MPU_HOSTCOUNT</tt> calls to
      <tt>mpu_batch</tt>. It indicates that no result is (yet) ready.
      <tt>result</tt> is the null vector, <tt>[]</tt>. <tt>seqno</tt> is zero.
      <tt>udata</tt> is the null vector, <tt>[]</tt>.</td>
    </tr>
    <tr>
      <td><tt>&#39;&#39;</tt></td>
      <td>After the first <tt>MPU_HOSTCOUNT</tt> calls, <tt>mpu_batch</tt> will
      wait until one of the hosts has finished its command (issued by one of
      the previous <tt>mpu_batch</tt> calls). If command has been successfully
      completed on its remote host, <tt>mpu_batch</tt> returns with the empty
      token result code. <tt>result</tt> stores the return value of the
      command. <tt>udata</tt> stores the user data of the command.
      <tt>seqno</tt> indicates which result is being returned: It is the
      ordinal number of the <tt>mpu_batch</tt> call initiating the command. The
      call numbers are integers starting from 1.</td>
    </tr>
    <tr>
      <td><tt>&#39;error&#39;</tt></td>
      <td>After the first <tt>MPU_HOSTCOUNT</tt> calls, <tt>mpu_batch</tt>
      waits for the next host that has finished its command. If command has
      been terminated due to an error, <tt>mpu_batch</tt> returns with the
      result code <tt>&#39;error&#39;</tt>. <tt>result</tt> stores the
      generated error message. <tt>udata</tt> and <tt>seqno</tt> are the same
      as those for the result code <tt>&#39;&#39;</tt> above.</td>
    </tr>
    <tr>
      <td><tt>&#39;eof&#39;</tt></td>
      <td>After all results for all data items have been retrieved from the
      remote hosts, <tt>mpu_batch</tt> returns with the return code
      <tt>eof</tt>. <tt>result</tt> is the null vector, <tt>[]</tt>.
      <tt>seqno</tt> is zero. <tt>udata</tt> is the null vector,
      <tt>[]</tt>.</td>
    </tr>
  </table>

<p>The first <tt>MPU_HOSTCOUNT</tt> calls to <tt>mpu_batch</tt> will return
  <tt>&#39;skip&#39;</tt> indicating that there are no more results. The next
  call will wait until one of the previous calculations is completed and the
  new calculation will be sent to the host that completed its calculation. The
  last <tt>MPU_HOSTCOUNT+1</tt> calls will be given a <tt>cmd</tt> of
  <tt>&#39;&#39;</tt>, the empty token. The first <tt>MPU_HOSTCOUNT</tt> of
  these will return results while the last will return
  <tt>&#39;eof&#39;</tt>.</p>

<p>For example, suppose that a global function <tt>MyFcn</tt> exists on all
  hosts. Suppose that on host number 1, a function called <tt>GetNextItem</tt>
  returns the next value to give to <tt>MyFcn</tt> and <tt>[]</tt> when there
  are no more (e.g., read from a file). Then, to distribute the calls to
  <tt>MyFcn</tt> the following code could be used:</p>

<pre class="code">
global function MyFcn_mpu []
    local item, cmd = &#39;call&#39;;

    loop
        if cmd &lt;&gt; &#39;&#39; then
            item = GetNextItem [];
            if isnull item then cmd = &#39;&#39;; endif
        endif

        local [res, code, seqno, udata] = mpu_batch [cmd, &#39;MyFcn&#39;, item, item];

        if code == &#39;&#39; then
            // ... res contains the successful result
            // ... udata contains the original item passed
        elseif code == &#39;error&#39; then
            // ... res contains the token error message
            // ... udata contains the original item passed
        elseif code == &#39;skip&#39; then
            // ... no results available
        elseif code == &#39;eof&#39; then
            break;
        endif
     endloop
endfunction
</pre>

<p>If there are <tt>N</tt> items returned by <tt>GetNextItem</tt> then the
  loop in the above code will be executed <tt>N+MPU_HOSTCOUNT+1</tt> times.
  <!-- ======== mpu_call, mpu_eval, mpu_load, mpu_run, mpu_script ======== -->
</p>
<a id="mpu_script"></a>
<a id="mpu_run"></a>
<a id="mpu_load"></a>
<a id="mpu_eval"></a>
<a id="mpu_call"></a>
<hr noshade="noshade" />

<pre>[result,code] = <span class=
  "fcndef">mpu_call</span>   [ host, fcn, arg, file ]
[result,code] = <span class="fcndef">mpu_eval</span>   [ host, expr, arg ]
[result,code] = <span class="fcndef">mpu_load</span>   [ host, src ]
[result,code] = <span class="fcndef">mpu_run</span>    [ host, src, arg, rfcn ]
[result,code] = <span class="fcndef">mpu_script</span> [ host, src, arg ]
</pre>

<p>The <tt>mpu_call</tt>, <tt>mpu_eval</tt>, <tt>mpu_load</tt>,
  <tt>mpu_run</tt> and <tt>mpu_script</tt> functions are multi-processor
  analogues of the <tt>task_*</tt> functions of the same suffix. Unlike the
  <tt>task_*</tt> functions, however, the <tt>mpu_*</tt> functions are
  vectorized. For example, <tt>mpu_load</tt> will load the source in
  <tt>src(i)</tt> on host <tt>host(i)</tt> and return the result of the
  operation in <tt>result(i)</tt> with return code in <tt>code(i)</tt>. The
  <tt>result</tt> and <tt>code</tt> return values are the same as for the
  <tt>task_*</tt> versions of these functions. Parameters <tt>fcn</tt>,
  <tt>expr</tt>, <tt>src</tt>, <tt>arg</tt>, <tt>file</tt> and <tt>rfcn</tt>
  specify the arguments supplied to the corresponding SVL functions on the
  remote hosts.</p>

<p>The trailing parameters <tt>arg</tt>, <tt>file</tt> and <tt>rfcn</tt> are
  optional. A missing (or empty) trailing parameter will cause the
  corresponding SVL functions be given an empty argument (on each of the remote
  hosts). In other words, a missing (or empty) trailing value is interpreted as
  <tt>[[]]</tt>.</p>

<p>For example, the expression</p>

<pre class="code">
first mpu_call [K, &#39;cd&#39;]
</pre>

<p>returns the current working directory of host K, while the expression</p>

<pre class="code">
first mpu_eval [K, &#39;HOSTNAME&#39;]
</pre>

<p>returns the name of host K. In <tt>mpu_eval</tt>, each parameter
  <tt>expr(i)</tt> must be a token or a string containing a valid SVL
  expression.</p>

<p>In <tt>mpu_load</tt>, <tt>mpu_run</tt>, or <tt>mpu_script</tt>, each
  parameter <tt>src(i)</tt> must specify a valid SVL program. If
  <tt>src(i)</tt> is a token, then it is interpreted by <tt>host(i)</tt> as the
  name of a file (on that host). If <tt>src(i)</tt> is a string, then it is
  interpreted as the contents of an SVL source file.</p>

<p>For example, to cause all hosts in a multi-processor to individually run
  the SVL file <tt>&#39;~user/myfile.svl&#39;</tt> with argument <tt>[]</tt>,
  one can use</p>

<pre class="code">
mpu_run [igen MPU_HOSTCOUNT, &#39;~user/myfile.svl&#39;]
</pre>

<p>assuming that <tt>~user/myfile.svl</tt> is visible on each processor. An
  alternative method is to supply the source code directly:</p>

<pre class="code">
src = freadb [ &#39;~user/myfile.svl&#39;, &#39;char&#39;, INT_MAX ];
mpu_run [igen MPU_HOSTCOUNT, [src]]
</pre>

<p>which requires only that <tt>&#39;~usr/myfile.svl&#39;</tt> be visible
  from the host calling <tt>mpu_run</tt>.</p>

<p><b>Cancellation.</b> Functions such as <tt>mpu_call</tt>,
  <tt>mpu_eval</tt> or <tt>mpu_batch</tt> cause a new task being created on
  each of the (specified) remote hosts. The remote tasks perform the requested
  action and send their results back to the calling task on the sender host. If
  the calling task terminates before the <tt>mpu_*</tt> function returns with
  its result, all these remote tasks are automatically cancelled.</p>

<p>For example, command</p>

<pre class="code">
expr = &#39;for i=1, Inf loop sleep 0.5; mpu_print i; endloop&#39;;
t = task_key -1; mpu_eval [2, expr]
</pre>

<p>will continue to print messages on the root console until the calling task
  is cancelled from the cancel menu or by</p>

<pre class="code">
task_kill t
</pre>

<p>Note, however, that messages sent by a (subsequently) cancelled task and
  not yet received by some other task will <i>not</i> be destroyed.</p>

<p><b>Latency.</b> Evaluation of <tt>mpu_*</tt> functions is subject to
  significant latencies. To maintain efficient use of the communication
  channels, it is recommended that <tt>mpu_*</tt> functions are called
  infrequently (a few calls per second) and that program data are transferred
  in sizeable chunks (several KB).</p>

<p>The following code fragment measures the approximate time required to send
  a 32 KB message to host K and back:</p>

<pre class="code">
msg = rep [&quot; &quot;, 0x8000]
tm = clock[];
mpu_call [K, &#39;id&#39;, [[msg]]];
print clock[] - tm;
</pre>
<!-- ================== mpu_portalloc, mpu_portfree ================== -->
<a id="ALLOC"></a>
<a id="mpu_portfree"></a>
<a id="mpu_portalloc"></a>
<hr noshade="noshade" />

<pre>port = <span class="fcndef">mpu_portalloc</span> []
<span class="fcndef">mpu_portfree</span> port
</pre>

<p>SVL tasks on different hosts communicate with each other via communication
  objects called <i>ports</i>. Each task can allocate its own unique
  communication port or ports with function <tt>mpu_portalloc</tt>. Each port
  also encode the host of the calling task. The maximum number of ports that
  can be allocated on a single host at once is stored in the constant
  <tt>MPU_PORTCOUNT</tt>. <tt>mpu_portalloc</tt> generates an error if no more
  ports are available.</p>

<p>When a communication port is no longer needed by the task, it should be
  released for use by other by calling <tt>mpu_portfree</tt>. Only the task
  that allocated the port can free it. Any attempts to free a port that was
  allocated by other tasks or that does not exist will be quietly ignored.</p>

<p>In order to send a message to another host, the destination port must be
  allocated on the destination host and communicated to the sender, for example
  as a parameter of a remote procedure call.
  <!-- ================== mpu_send ================== -->
<a id="SEND"></a>
</p>
<a id="mpu_send"></a>
<hr noshade="noshade" />

<pre>reply_msg = <span class=
  "fcndef">mpu_send</span> [receiver_port, msg, reply_port]
reply_msg = <span class=
"fcndef">mpu_send</span> [receiver_port, msg, reply_port, timeout]
</pre>

<p>The <tt>mpu_send</tt> function is used to initiate communication with
  another task assumed to be (or soon be) performing an <tt>mpu_receive</tt>.
  The communication sequence is as follows: Task A <i>receives</i> (task A
  waits); Task B <i>sends</i> to Task A (task B waits); Task A continues and
  <i>replies</i> to task B; Task B continues. The arguments and return value of
  <tt>mpu_send</tt> are:</p>
  <dl>
    <dt><tt>receiver_port</tt></dt>
    <dd>The port upon which the intended receiver is assumed to wait. This port
    must be (somehow) communicated to senders prior to communication. If
    <tt>receiver_port</tt> is zero, then the function examines the state of
    <tt>reply_port</tt>. If a reply message from a previously issued
    <tt>mpu_send</tt> call (that has timed out) is still expected to arrive at
    the port, the function will wait for the reply. Otherwise, the function
    will return immediately with its <tt>msg</tt> argument. If
    <tt>receiver_port</tt> is nonzero and <tt>reply_port</tt> is zero then the
    argument <tt>msg</tt> will be sent to <tt>receiver_port</tt>. However, the
    calling task will not wait and <tt>mpu_send</tt> will return immediately
    with <tt>[]</tt>. Otherwise, the calling task will wait while the message
    is sent to <tt>receiver_port</tt> and until a reply is transmitted back.
    <tt>mpu_send</tt> will then return with the reply. If
    <tt>receiver_port</tt> is found to be invalid when the message is delivered
    to the remote host or becomes invalid before the remote hosts responds to
    the sender with <tt>mpu_reply</tt>, the originating task will report an
    error. However, if <tt>receiver_port</tt> was given as a negative number,
    then the originating task will not report an error, even if the port is
    invalid.</dd>
    <dt><tt>msg</tt></dt>
    <dd>The arbitrary value that will be transmitted to the intended receiver.
    There are no pre-set limits on how large <tt>msg</tt> can be; however, in
    general, it is not a good idea to send very large messages.</dd>
    <dt><tt>reply_port</tt></dt>
    <dd>The local port that the receiver is supposed to use to reply to the
    transmission. If <tt>reply_port</tt> is 0 then no reply is expected and
    <tt>mpu_send</tt> will return immediately (the receiver will be given a
    <tt>reply_port</tt> of zero). It is an error for <tt>reply_port</tt> to be
    remote. If <tt>reply_port</tt> is given as negative number, it will be
    transmitted to the receiver also as a negative number. When using a
    negative <tt>reply_port</tt>, the receiver will not report an error in case
    of <tt>reply_port</tt> becoming invalid before the transmission is
    completed.</dd>
    <dt><tt>reply_msg</tt></dt>
    <dd>The arbitrary value that will be transmitted back from the receiver. If
    the <tt>reply_port</tt> is 0, then the sender will not wait for the reply
    and the <tt>reply_msg</tt> is set to <tt>[]</tt>.</dd>
    <dt><tt>timeout</tt></dt>
    <dd>If the timeout value is specified, the function will always return
    within the given time. If a reply was requested (with non-zero value of
    <tt>reply_port</tt>) and no reply value has been received, the function
    will return <tt>[]</tt>; the user is then expected to wait for the reply by
    calling <tt>mpu_send</tt> with the same reply port but zero receiver
    port.</dd>
  </dl>

<p>For example:</p>

<pre class="code">
mpu_send [ receiver_port, &#39;hello&#39;, 0 ]
</pre>

<p>sends <tt>&#39;hello&#39;</tt> to <tt>receiver_port</tt> without waiting
  for a reply, while</p>

<pre class="code">
local port = mpu_portalloc [];
    reply_msg = mpu_send [ receiver_port, &#39;hello&#39;, port ];
    mpu_portfree port;
</pre>

<p>sends <tt>&#39;hello&#39;</tt> to <tt>receiver_port</tt> and waits for a
  reply on the allocated local port <tt>port</tt>. A task that repeatedly asks
  a dispatcher task for work to do will typically have the following
  structure:</p>

<pre class="code">
function Worker boss_port
        local my_port = mpu_portalloc [];

        while not done loop
            local work = mpu_send [ boss_port, &#39;hello&#39;, my_port ];
            .... perform the work ...
        endloop

        mpu_portfree my_port;
    endfunction
</pre>

<p><b>Warning!</b> A call to <tt>mpu_send</tt> may never return if no task
  calls <tt>mpu_receive</tt> on the intended receiver host. If two tasks
  attempt to send to each other a <i>deadlock</i> can result and both tasks
  will wait indefinitely.
  <!-- ================== mpu_receive, mpu_reply ================== -->
<a id="RECV"></a>
</p>
<a id="mpu_reply"></a>
<a id="mpu_receive"></a>
<hr noshade="noshade" />

<pre>[reply_port, msg] = <span class=
  "fcndef">mpu_receive</span> receiver_port
[reply_port, msg] = <span class=
"fcndef">mpu_receive</span> [receiver_port, timeout]
<span class="fcndef">mpu_reply</span> [reply_port, reply_msg]
</pre>

<p>When a task wants to wait for another task to send information (via
  <tt>mpu_send</tt>) it must call <tt>mpu_receive</tt> followed by
  <tt>mpu_reply</tt>. The communication sequence follows: Task A
  <i>receives</i> (task A waits); Task B <i>sends</i> to Task A (task B waits);
  Task A continues and <i>replies</i> to task B; Task B continues.</p>

<p>The argument and return values of <tt>mpu_receive</tt> are:</p>
  <dl>
    <dt><tt>receiver_port</tt></dt>
    <dd>The local port upon which the calling task will wait. If no sender
    sends to this port then the calling task will wait forever. It is an error
    to wait on the zero port or a remote port.</dd>
    <dt><tt>timeout</tt></dt>
    <dd>If the timeout value is specified, the function will always return
    within the given time. If no message has arrived within that time, the
    function will return <tt>[]</tt>.</dd>
    <dt><tt>reply_port</tt></dt>
    <dd>The port to which a reply must be sent. If the <tt>reply_port</tt> is
    zero then a reply is not expected and does not have to be sent. If a reply
    is sent to port zero, it will be discarded.</dd>
    <dt><tt>msg</tt></dt>
    <dd>The value that the caller of <tt>mpu_send</tt> sent.</dd>
  </dl>

<p>Unless the <tt>reply_port</tt> is zero, the sender of the message waits
  for the message to be received and a reply to be sent back. To send a reply
  back to the sender, the receiver must call function <tt>mpu_reply</tt> with
  the following arguments:</p>
  <dl>
    <dt><tt>reply_port</tt></dt>
    <dd>The port upon which the sender is waiting; this is the
    <tt>reply_port</tt> value returned by <tt>mpu_receive</tt>. If the
    <tt>reply_port</tt> is zero then the <tt>reply_msg</tt> is discarded. If
    <tt>reply_port</tt> is found to be invalid when the reply message is
    delivered to the remote (sender) host, the task calling <tt>mpu_reply</tt>
    will report an error. However, if <tt>reply_port</tt> is given as a
    negative number, then the calling task will not report an error, even if
    the port is invalid.</dd>
    <dt><tt>reply_msg</tt></dt>
    <dd>The arbitrary value to be transmitted back to the sender. There are no
    pre-set limits on how large <tt>reply_msg</tt> can be; however, in general,
    it is not a good idea to return very large messages.</dd>
  </dl>

<p>A typical dispatcher of work to various worker tasks can have the
  following structure:</p>

<pre class="code">
function Dispatcher []
        local my_port = mpu_portalloc [];

        while not done loop
            local [worker_port, msg] = mpu_receive my_port;
            local work = ... find some work to do ...
            mpu_reply [ worker_port, work ];
        endloop

        mpu_portfree my_port;
    endfunction
</pre>
<!-- ================== mpu_chardecode, mpu_charencode ================== -->
<a id="ENCODE"></a>
<a id="mpu_chardecode"></a>
<a id="mpu_charencode"></a>
<hr noshade="noshade" />

<pre>char_data = <span class="fcndef">mpu_charencode</span> value
value     = <span class="fcndef">mpu_chardecode</span> char_data
</pre>

<p>These functions are used internally to convert SVL values before and after
  transmission to another processor. The function <tt>mpu_charencode</tt>
  converts an arbitrary vector <tt>value</tt> into a flat vector of
  non-printable, binary character data <tt>char_data</tt>. The function
  <tt>mpu_chardecode</tt> does the reverse: it converts a flat vector of
  characters (as returned by <tt>mpu_charencode</tt>) into the original vector
  <tt>value</tt>. An error results if the data passed to
  <tt>mpu_chardecode</tt> doesn&#39;t have the correct format.
  <!-- ms: not needed - all SVL values (had better) work

<p>
Portability considerations mean that SVL guarantees accurate transmission of
8-bit characters, 32-bit integers, 64-bit IEEE floating point numbers.  These
functions can be used to test if values can be sent and received accurately.
If <tt>(y&nbsp;= mpu_chardecode mpu_charencode&nbsp;x)</tt> and
<tt>neL[x,y]</tt> then
<tt>x</tt> contains non-portable data.
--></p>

<p><b>Note:</b> In general, there is no need to use these functions for
  multi-processor communication: all message values are automatically
  converted.</p>

<p><b>Warning!</b> The encoded format may change from version to version:
  <i>do not rely on the format being fixed and do not save the character data
  in files</i>. <!-- ================== mpu_password ================== -->
<a id="PASSWD"></a>
</p>
<a id="mpu_password"></a>
<hr noshade="noshade" />

<pre>scrambled_token = <span class=
  "fcndef">mpu_password</span> password_token
</pre>

<p>The <tt>mpu_password</tt> function is used to compute scrambled password
  values from plain text password values for use in machine file specifications
  and the <tt>SVL_MPU_PASSWORD</tt> environment variable. The plain text
  password must contain no more than 20 characters.
  <!-- ================== mpu_distance ================== -->
<a id="DIST"></a>
</p>
<a id="mpu_distance"></a>
<a id="MPU_NEIGHBORS"></a>
<a id="MPU_DIGITBITS"></a>
<a id="MPU_DIGITCOUNT"></a>
<hr noshade="noshade" />

<pre>n_hops = <span class="fcndef">mpu_distance</span> [hostA, hostB]
</pre>

<p>The <tt>mpu_distance</tt> function can be used for subtle optimizations of
  communication patterns between hosts. The function returns then number of
  message repeats (&quot;hops&quot;) necessary for transmitting a message
  between the two given hosts. When the second argument is null, it is assumed
  to be the current host (the caller). Larger values will generally indicate
  longer communication delays between the hosts.</p>

<pre>
MPU_NEIGHBORS
MPU_DIGITBITS
MPU_DIGITCOUNT
</pre>

<p>These constants can be used for subtle optimizations of communication
  patterns between hosts. Constant <tt>MPU_NEIGHBORS</tt> contains the list of
  hosts whose distance to the current host is exactly 1 (hop). Constant
  <tt>MPU_DIGITBITS</tt> stores the value of the machine file parameter
  <tt>$mpu-digitbits</tt>. Constant <tt>MPU_DIGITCOUNTS</tt> stores the
  smallest number such that any host number is representable in
  <tt>MPU_DIGITBITS*MPU_DIGITCOUNTS</tt> bits.</p>

<h1>See Also</h1>
<table class="functionList">
  <tr>
    <td valign="top"><a href="calletc.htm#call">call</a><br />
    <a href="runetc.htm#eval">eval</a><br />
    <a href="loadetc.htm#load">load</a><br />
    <a href="runetc.htm#run">run</a><br />
    <a href="runetc.htm#script">script</a></td>
    <td valign="top"><a href=
    "tskcall.htm#task_call">task_call</a><br />
    <a href="tskcall.htm#task_eval">task_eval</a><br />
    <tt>&nbsp;</tt><br />
    <a href="tskcall.htm#task_run">task_run</a><br />
    <a href="tskcall.htm#task_script">task_script</a></td>
  </tr>
</table>

<p><a href="introcomm.htm">SVL Task Communication Functions</a></p>
  <!-- START MOE_FOOTER -->
  <div class="MOE_FOOTER">
    <img src="../../images/ccgicon.png" /> <a href="../../index.htm"></a>
    <a href="../../legal.htm"></a> &copy;<span class="versionyear"></span>
    <a href="http://www.chemcomp.com"></a>. All rights reserved.<br />
    <a href="mailto:info@chemcomp.com"></a>
  </div><!-- END MOE_FOOTER -->
</div>
</div>
</body>
</html>

