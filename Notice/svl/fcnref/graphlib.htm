<!DOCTYPE html>
<html>

<!--
!!    MOE On-Line Manuals
!!    COPYRIGHT (C) CHEMICAL COMPUTING GROUP ULC.  ALL RIGHTS RESERVED.
!!-->
<head>
  <meta http-equiv="x-ua-compatible" content="IE=9" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../include/manstyle.css" />
  <link rel="icon" type="image/png" href="../../images/ccgicon.png" />
  <link rel="shortcut icon" type="image/png" href="../../images/ccgicon.png" />
  <meta name="keywords" content="keywords:" />
  <meta name="keywords" content="functions: graph_adjacency" />
  <meta name="keywords" content="functions: graph_articulator" />
  <meta name="keywords" content="functions: graph_automorphism_close" />
  <meta name="keywords" content="functions: graph_automorphism_next" />
  <meta name="keywords" content="functions: graph_automorphism_open" />
  <meta name="keywords" content="functions: graph_bfs" />
  <meta name="keywords" content="functions: graph_bfspath" />
  <meta name="keywords" content="functions: graph_block" />
  <meta name="keywords" content="functions: graph_block_list" />
  <meta name="keywords" content="functions: graph_blockarticulator" />
  <meta name="keywords" content="functions: graph_canonize_cycles" />
  <meta name="keywords" content="functions: graph_ccomponent" />
  <meta name="keywords" content="functions: graph_ccomponent_list" />
  <meta name="keywords" content="functions: graph_center" />
  <meta name="keywords" content="functions: graph_chain" />
  <meta name="keywords" content="functions: graph_connector" />
  <meta name="keywords" content="functions: graph_cycleneighbors" />
  <meta name="keywords" content="functions: graph_dfs1" />
  <meta name="keywords" content="functions: graph_dfs2" />
  <meta name="keywords" content="functions: graph_diameter" />
  <meta name="keywords" content="functions: graph_distance" />
  <meta name="keywords" content="functions: graph_ear" />
  <meta name="keywords" content="functions: graph_eblock_list" />
  <meta name="keywords" content="functions: graph_eccentricity" />
  <meta name="keywords" content="functions: graph_ecut" />
  <meta name="keywords" content="functions: graph_ecutE" />
  <meta name="keywords" content="functions: graph_edges" />
  <meta name="keywords" content="functions: graph_expandpaths" />
  <meta name="keywords" content="functions: graph_firstpath" />
  <meta name="keywords" content="functions: graph_get" />
  <meta name="keywords" content="functions: graph_hyperneighbors" />
  <meta name="keywords" content="functions: graph_maxmatch" />
  <meta name="keywords" content="functions: graph_mget" />
  <meta name="keywords" content="functions: graph_neighbors" />
  <meta name="keywords" content="functions: graph_npaths" />
  <meta name="keywords" content="functions: graph_perimeter" />
  <meta name="keywords" content="functions: graph_perm" />
  <meta name="keywords" content="functions: graph_radius" />
  <meta name="keywords" content="functions: graph_rot" />
  <meta name="keywords" content="functions: graph_sconnector" />
  <meta name="keywords" content="functions: graph_scycle" />
  <meta name="keywords" content="functions: graph_scycle_list" />
  <meta name="keywords" content="functions: graph_shortestpath" />
  <meta name="keywords" content="functions: graph_spath" />
  <meta name="keywords" content="functions: graph_spath2" />
  <meta name="keywords" content="functions: graph_stretch" />
  <meta name="keywords" content="functions: graph_tr" />
  <meta name="keywords" content="functions: graph_triblock_list" />
  <meta name="keywords" content="functions: graph_uedges" />
  <meta name="keywords" content="functions: graph_uneighbors" />
  <meta name="keywords" content="functions: graph_vcut" />
  <meta name="keywords" content="functions: graph_walkclass" />
  <title>Graph Functions</title>
</head>
<body>
<div class="center-page">
  <!-- START MOE_HEADER -->
  <div class="MOE_HEADER">
    <a href="../../index.htm"><img src="../../images/ccglogo.png" /></a>
    <a href="../../index.htm"><div class="moeversion"></div></a>
    Graph Functions
  </div>
<!-- END MOE_HEADER -->
<div class="content">

<h1>Syntax</h1>

<pre>
    amatrix = <a class="fcnlink" href=
"#graph_adjacency">graph_adjacency</a> nbrlist
    dmatrix = <a class="fcnlink" href=
"#graph_distance">graph_distance</a> nbrlist

    nbrlist = <a class="fcnlink" href=
"#graph_neighbors">graph_neighbors</a> [xA, xB]
    nbrlist = <a class="fcnlink" href=
"#graph_uneighbors">graph_uneighbors</a> [xA, xB]

    nbrlist = <a class="fcnlink" href=
"#graph_neighbors">graph_neighbors</a> [xA, xB, n]
    nbrlist = <a class="fcnlink" href=
"#graph_uneighbors">graph_uneighbors</a> [xA, xB, n]

    [xA,xB] = <a class="fcnlink" href="#graph_edges">graph_edges</a> nbrlist
    [xA,xB] = <a class="fcnlink" href="#graph_uedges">graph_uedges</a> nbrlist

    ecc = <a class="fcnlink" href=
"#graph_eccentricity">graph_eccentricity</a> nbrlist
    rad = <a class="fcnlink" href="#graph_radius">graph_radius</a> nbrlist
    dia = <a class="fcnlink" href="#graph_diameter">graph_diameter</a> nbrlist
    cmask = <a class="fcnlink" href="#graph_center">graph_center</a> nbrlist
    pmask = <a class="fcnlink" href=
"#graph_perimeter">graph_perimeter</a> nbrlist

    nbrlist = <a class="fcnlink" href="#graph_tr">graph_tr</a> nbrlist
    nbrlist = <a class="fcnlink" href="#graph_rot">graph_rot</a> [nbrlist, k]

    nbrlist = <a class="fcnlink" href=
"#graph_mget">graph_mget</a> [nbrlist, mask]
    nbrlist = <a class="fcnlink" href="#graph_get">graph_get</a> [nbrlist, idx]
    nbrlist = <a class="fcnlink" href=
"#graph_stretch">graph_stretch</a> [nbrlist, seg]
    nbrlist = <a class="fcnlink" href=
"#graph_perm">graph_perm</a> [nbrlist, pos]

    nbrlist = <a class="fcnlink" href=
"#graph_vcut">graph_vcut</a> [nbrlist, idx]
    nbrlist = <a class="fcnlink" href=
"#graph_ecut">graph_ecut</a> [nbrlist, [idx1, idx2]]
    nbrlist = <a class="fcnlink" href=
"#graph_ecutE">graph_ecutE</a> [nbrlist, [idx1, idx2]]
    path = <a class="fcnlink" href="#graph_chain">graph_chain</a> [nbrlist, x]
    path = <a class="fcnlink" href=
"#graph_chain">graph_chain</a> [nbrlist, [x, p]]
    [pathA, pathB] = <a class="fcnlink" href=
"#graph_ear">graph_ear</a> [nbrlist, [a, b]]

    [dis, fin, par, low, cc] = <a class="fcnlink" href=
"#graph_dfs1">graph_dfs1</a> nbrlist
    [dis, fin, par, low, cc, tc, ebc, bc] = <a class="fcnlink" href=
"#graph_dfs2">graph_dfs2</a> nbrlist
    compnum = <a class="fcnlink" href=
"#graph_ccomponent">graph_ccomponent</a> nbrlist
    list = <a class="fcnlink" href=
"#graph_ccomponent_list">graph_ccomponent_list</a> nbrlist
    list = <a class="fcnlink" href="#graph_block">graph_block</a> nbrlist
    block = <a class="fcnlink" href=
"#graph_block_list">graph_block_list</a> nbrlist
    eblock = <a class="fcnlink" href=
"#graph_eblock_list">graph_eblock_list</a> nbrlist
    amask = <a class="fcnlink" href=
"#graph_articulator">graph_articulator</a> nbrlist
    amask = <a class="fcnlink" href=
"#graph_blockarticulator">graph_blockarticulator</a> nbrlist
    list = <a class="fcnlink" href=
"#graph_triblock_list">graph_triblock_list</a> nbrlist
    con = <a class="fcnlink" href=
"#graph_connector">graph_connector</a> [nbrlist, m]
    con = <a class="fcnlink" href=
"#graph_sconnector">graph_sconnector</a> [nbrlist, m]

    [dis, fin, par, depth, cc] = <a class="fcnlink" href=
"#graph_bfs">graph_bfs</a> nbrlist
    mpath = <a class="fcnlink" href=
"#graph_bfspath">graph_bfspath</a> [nbrlist, src, dst, depth]

    mpath = <a class="fcnlink" href=
"#graph_spath">graph_spath</a> [nbrlist, [a, b]]
    mpath = <a class="fcnlink" href=
"#graph_spath2">graph_spath2</a> [nbrlist, [a, b]]
    mpath = <a class="fcnlink" href=
"#graph_scycle">graph_scycle</a> [nbrlist, [a, b]]
    list = <a class="fcnlink" href=
"#graph_expandpaths">graph_expandpaths</a> [nbrlist, mpath]
    npaths = <a class="fcnlink" href=
"#graph_npaths">graph_npaths</a> [nbrlist, mpath]
    path = <a class="fcnlink" href=
"#graph_firstpath">graph_firstpath</a> [nbrlist, mpath]
    list = <a class="fcnlink" href=
"#graph_canonize_cycles">graph_canonize_cycles</a> list
    [list1, list2, list3] = <a class="fcnlink" href=
"#graph_scycle_list">graph_scycle_list</a> nbrlist
    path = <a class="fcnlink" href=
"#graph_shortestpath">graph_shortestpath</a> [nbrlist, src, dst]

    nbrlist = <a class="fcnlink" href=
"#graph_cycleneighbors">graph_cycleneighbors</a> clist
    nbrlist = <a class="fcnlink" href=
"#graph_hyperneighbors">graph_hyperneighbors</a> hlist

    cnum = <a class="fcnlink" href=
"#graph_walkclass">graph_walkclass</a> [nbrlist, label]
    mask = <a class="fcnlink" href=
"#graph_maxmatch">graph_maxmatch</a> [xA, xB, weight]

    autokey = <a class="fcnlink" href=
"#graph_automorphism_open">graph_automorphism_open</a> [nbrlist, label]
    idx = <a class="fcnlink" href=
"#graph_automorphism_next">graph_automorphism_next</a> autokey
    <a class="fcnlink" href=
"#graph_automorphism_close">graph_automorphism_close</a> autokey
</pre>

<h1>Description</h1>

<p>SVL provides a number of functions for manipulating graphs. A
  <i>graph</i>, <i>G</i>, is a pair (<i>V</i>,<i>E</i>) where <i>V</i> is a set
  of <i>n</i> <i>vertices</i> and <i>E</i> a set of <i>m</i> <i>edges</i> which
  are vertex pairs {(<i>a<sub>i</sub></i>,<i>b<sub>i</sub></i>)}. A graph is
  <i>undirected</i> if whenever (<i>a</i>,<i>b</i>) is in <i>E</i> then so is
  (<i>b</i>,<i>a</i>). The <i>degree</i> of a vertex is the number of edges in
  which it participates as the first member of the vertex pair making up the
  edge.</p>

<p>In SVL, graphs can be represented in a number of ways. The most common
  forms are as follows.</p>
  <ul>
    <li>The <i>neighbor list</i> representation of a graph encodes the edge set
    <i>E</i> with a vector <tt>nbrlist</tt> of neighbor vectors. For each
    vertex <tt>i</tt> in <i>V</i>, <tt>nbrlist</tt> gives the neighbors of
    <tt>i</tt>. That is, <tt>nbrlist</tt> has length <i>n</i> and
    <tt>nbrlist(i)</tt> is a vector of indices of vertices that appear with
    vertex <tt>i</tt> in an edge in which <tt>i</tt> is the first vertex of the
    vertex pair making up the edge. In such a representation <span class=
    "nobr"><i>E</i> = {(<tt>i</tt>, <tt>nbrlist(i)(j)</tt>) | i =
    1,2,...<i>n</i>}</span> are the edges of the graph and the degree of each
    vertex is given by <tt>app&nbsp;length&nbsp;nbrlist</tt>.</li>
    <li>The <i>edge list</i> representation of a graph encodes the edge set
    explicitly. The edge set <i>E</i> is represented as two vectors of indices
    of vertices, <tt>xA</tt> and <tt>xB</tt>, each of which has length
    <i>m</i>. In this representation, (<tt>xA(i)</tt>,&nbsp;<tt>xB(i)</tt>)
    denotes edge (<i>a<sub>i</sub></i>,&nbsp;<i>b<sub>i</sub></i>) and
    <tt>l_length&nbsp;[xA,xB]</tt> is the number of edges in the graph.</li>
  </ul>
<a id="graph_distance"></a>
<a id="graph_adjacency"></a>
<hr noshade="noshade" />

<pre>amatrix = <span class="fcndef">graph_adjacency</span> nbrlist
dmatrix = <span class="fcndef">graph_distance</span> nbrlist
</pre>

<p>Given a graph in neighbor list representation, <tt>graph_adjacency</tt>
  returns <tt>amatrix</tt>, the <i>n</i> by <i>n</i> adjacency matrix of the
  graph. The return value is such that <tt>amatrix(i)(j)</tt> is one if
  <tt>j</tt> is in <tt>nbrlist(i)</tt>, zero otherwise.</p>

<p>Given a graph in neighbor list representation, <tt>graph_distance</tt>
  returns, <tt>dmatrix</tt>, the <i>n</i> by <i>n</i> distance matrix of the
  graph. The return value is such that <tt>dmatrix(i)(j)</tt> is the length of
  the shortest path between vertices <tt>i</tt> and <tt>j</tt>. If no path
  between the two vertices exists, their distance is set to <i>n</i>, the
  number of vertices in the graph. <!--

<p>For example,
<span class="nobr"><tt>graph_adjacency [2,3,[]]</tt></span> returns
<span class="nobr"><tt>[[0,1,0], [0,0,1], [0,0,0]]</tt></span>, while
<span class="nobr"><tt>graph_distance [2,3,[]]</tt></span> returns
!!! graph distance should report distance of a digraph
<span class="nobr"><tt>[[0,1,2], [4,0,1], [4,4,0]]</tt></span>.
--></p>
<a id="graph_uneighbors"></a>
<a id="graph_neighbors"></a>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_neighbors</span> [xA, xB]
nbrlist = <span class="fcndef">graph_uneighbors</span> [xA, xB]

nbrlist = <span class="fcndef">graph_neighbors</span> [xA, xB, n]
nbrlist = <span class="fcndef">graph_uneighbors</span> [xA, xB, n]
</pre>

<p>Given an edge list representation of a directed graph, <tt>[xA,xB]</tt>,
  <tt>graph_neighbors</tt> returns the neighbor list representation of the
  graph. For each vertex <i>a</i>, the function reports all vertices <i>b</i>
  such that, for some <i>k</i>, <i>a</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt> and
  <i>b</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt>.</p>

<p>Given an edge list representation of an undirected graph, <tt>[xA,xB]</tt>
  <tt>graph_uneighbors</tt> returns the neighbor list representation of the
  graph. If the input graph is not undirected, the function converts it to an
  undirected graph by adding missing reverse edges. For each vertex <i>a</i>,
  the function reports all vertices <i>b</i> such that, for some <i>k</i>,
  <i>a</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt> and
  <i>b</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt>, or
  <i>a</i>&nbsp;=&nbsp;<tt>xB(<i>k</i>)</tt> and
  <i>b</i>&nbsp;=&nbsp;<tt>xA(<i>k</i>)</tt>. For example,</p>

<pre>
    svl&gt; graph_neighbors [[1,2],[2,3]]
    [2, 3, []]

    svl&gt; graph_uneighbors [[1,2],[2,3]]
    [2, [1,3], 2]
</pre>

<p>If the optional third argument, <tt>n</tt>, is present, the graph
  represented by the returned neighbor list will be extended or truncated to
  contain exactly <tt>n</tt> vertices. For example,</p>

<pre>
    svl&gt; graph_uneighbors [[1,2,3], [2,3,4]]
    [ 2, [1,3], [2,4], 3 ]

    svl&gt; graph_uneighbors [[1,2,3], [2,3,4], 5]
    [ 2, [1,3], [2,4], 3, [] ]

    svl&gt; graph_uneighbors [[1,2,3], [2,3,4], 3]
    [ 2, [1,3], 2 ]
</pre>
<a id="graph_uedges"></a>
<a id="graph_edges"></a>
<hr noshade="noshade" />

<pre>[xA,xB] = <span class="fcndef">graph_edges</span> nbrlist
[xA,xB] = <span class="fcndef">graph_uedges</span> nbrlist
</pre>

<p>Given a neighbor list representation of a directed graph,
  <tt>graph_edges</tt> returns the directed edge list for each vertex.</p>

<p>The <tt>graph_uedges</tt> function returns the undirected set of edges;
  that is, <tt>xA(i)</tt>&nbsp;&lt;&nbsp;<tt>xB(i)</tt> with no duplicates. The
  function reports all pairs
  (<i>a</i>&nbsp;=&nbsp;<tt>xA(i)</tt>,&nbsp;<i>b</i>&nbsp;=&nbsp;<tt>xB(i)</tt>),
  such that <i>a</i>&nbsp;&le;&nbsp;<i>b</i> and (<i>a</i>,<i>b</i>) or
  (<i>b</i>,<i>a</i>) is an edge in the input graph. For example,</p>

<pre>
    svl&gt; graph_edges [2,3,[1,2]]
    [[1,2,3,3], [2,3,1,2]]

    svl&gt; graph_uedges [2,3,[1,2]]
    [[1,2,1], [2,3,3]]
</pre><!-- ==================== eccentricity etc ==================== -->
<a id="graph_perimeter"></a>
<a id="graph_center"></a>
<a id="graph_diameter"></a>
<a id="graph_radius"></a>
<a id="graph_eccentricity"></a>
<hr noshade="noshade" />

<pre>ecc = <span class="fcndef">graph_eccentricity</span> nbrlist
rad = <span class="fcndef">graph_radius</span> nbrlist
dia = <span class="fcndef">graph_diameter</span> nbrlist
cmask = <span class="fcndef">graph_center</span> nbrlist
pmask = <span class="fcndef">graph_perimeter</span> nbrlist
</pre>

<p>The <i>eccentricity</i> of graph vertex <i>a</i> is the longest distance
  between <i>a</i> and all other vertices in the graph.</p>

<p>Given a graph in neighbor list representation, <tt>graph_eccentricity</tt>
  returns the eccentricity of each vertex. For example,</p>

<pre>
    svl&gt; graph_eccentricity [2,[1,3],[]]
    [2,1,3]
</pre>

<p>Function <tt>graph_radius</tt> returns the graph <i>radius</i>, which is
  the minimum eccentricity of the graph.</p>

<p>Function <tt>graph_diameter</tt> returns the graph <i>diameter</i>, which
  is the maximum eccentricity of the graph.</p>

<p>Function <tt>graph_center</tt> returns the mask of the graph
  <i>center</i>, which is the set of vertices of eccentricity equal to the
  graph radius.</p>

<p>Function <tt>graph_perimeter</tt> returns the mask of the graph
  <i>perimeter</i>, which is the set of vertices of eccentricity equal to the
  graph diameter.
  <!-- =========== ccomponent, maxmatch, mget, walkclass =========== --></p>
<a id="graph_rot"></a>
<a id="graph_tr"></a>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_tr</span> nbrlist
nbrlist = <span class="fcndef">graph_rot</span> [nbrlist, k]
</pre>

<p>Given a directed graph in neighbor list representation, <tt>graph_tr</tt>
  reverses the edges of the graph and returns its neighbor list representation.
  For example,</p>

<pre>
    svl&gt; graph_tr [2,3,[]]
    [[],1,2]
</pre>

<p>If the input graph is undirected, the function has no effect.</p>

<p>Given a graph in neighbor list representation and an integer <i>k</i>,
  <tt>graph_rot</tt> rotates the vector of vertices by <i>k</i> positions to
  the right and returns the neighbor list of the resulting graph. Negative
  <i>k</i> rotates the vertices to the left. For example,</p>

<pre>
    svl&gt; graph_rot [[2,[],[],[]], 1]
    [[],3,[],[]]
</pre>
<a id="graph_perm"></a>
<a id="graph_stretch"></a>
<a id="graph_get"></a>
<a id="graph_mget"></a>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_mget</span> [nbrlist, mask]
nbrlist = <span class="fcndef">graph_get</span> [nbrlist, idx]
nbrlist = <span class="fcndef">graph_stretch</span> [nbrlist, seg]
nbrlist = <span class="fcndef">graph_perm</span> [nbrlist, pos]
</pre>

<p>Given a graph in neighbor list representation and a length <i>n</i> vertex
  mask, <tt>graph_mget</tt> returns the subgraph consisting of the vertices
  <tt>i</tt> for which <tt>mask(i)</tt> is nonzero, and the edges connecting
  such vertices.</p>

<p>Given a graph <i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>) in neighbor
  list representation, <tt>nbrlist</tt>, and a vector of <i>m</i> vertex
  indices, <tt>idx</tt>, function <tt>graph_get</tt> returns the neighbor list
  representation of a graph <i>H</i>=(<i>U</i>=1..<i>m</i>,&nbsp;<i>F</i>),
  such that (<i>a</i>,<i>b</i>) is an edge in <i>F</i> if and only if
  (<tt>idx</tt>(<i>a</i>),<tt>idx</tt>(<i>b</i>)) is also an edge in
  <i>E</i>.</p>

<p>Given a vector of segment lengths, <tt>graph_stretch</tt> returns a graph
  consisting of the vertices <tt>i</tt> replicated <tt>seg(i)</tt> times. The
  result of <tt>graph_stretch</tt> with segments <tt>seg</tt> is identical to
  the result of <tt>graph_get</tt> with indices
  <tt>idx=stretch[igen&nbsp;</tt><i>n</i><tt>,seg]</tt>, given the same
  neighbor list of <i>n</i> vertices.</p>

<p>Given a permutation vector, <tt>pos</tt>, <tt>graph_perm</tt> returns a
  graph consisting of the vertices <tt>i</tt> moved to position
  <tt>pos(i)</tt>. The result of <tt>graph_perm</tt> with permutation
  <tt>pos</tt> is identical to the result of <tt>graph_get</tt> with indices
  <tt>idx=perm[igen&nbsp;</tt><i>n</i><tt>,pos]</tt>, given the same neighbor
  list of <i>n</i> vertices.</p>
<a id="graph_ecut"></a>
<a id="graph_ecutE"></a>
<a id="graph_vcut"></a>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_vcut</span> [nbrlist, idx]
nbrlist = <span class="fcndef">graph_ecut</span> [nbrlist, [idx1, idx2]]
nbrlist = <span class="fcndef">graph_ecutE</span> [nbrlist, [idx1, idx2]]
</pre>

<p>Given a graph in neighbor list representation and a set or sets of
  vertices, functions <tt>graph_vcut</tt> and <tt>graph_ecut</tt> remove all
  edges incident to the given vertices and return the resulting subgraph.
  Function <tt>graph_vcut</tt> removes all edges that start or end at a vertex
  from the set <tt>idx</tt>. Function <tt>graph_ecut</tt> removes all edges
  that start at a vertex from the set <tt>idx1</tt> and end at a vertex from
  the set <tt>idx2</tt>. Function <tt>graph_ecutE</tt> interprets the pair of
  vectors <tt>idx1</tt> and <tt>idx2</tt> as a laminated list of edges to be
  removed; <tt>idx1</tt> and <tt>idx2</tt> must unit-extend to the same
  length.</p>

<pre>
    svl&gt; A = [[3,4], [3,4], [1,2], [1,2]]
    svl&gt; graph_vcut [A, 1]
    [ [], [3,4], 2, 2 ]
    svl&gt; graph_ecut [A, [[1,2],[3,4]]]
    [ [], [], [], [] ]
    svl&gt; graph_ecutE [A, [[1,2],[3,4]]]
    [4,3,2,1]
</pre>
<a id="graph_ear"></a>
<a id="graph_chain"></a>
<hr noshade="noshade" />

<pre>path = <span class="fcndef">graph_chain</span> [nbrlist, x]
path = <span class="fcndef">graph_chain</span> [nbrlist, [x, p]]
[pathA, pathB] = <span class="fcndef">graph_ear</span> [nbrlist, [a, b]]
</pre>

<p>Given a graph in neighbor list representation and one vertex, <tt>x</tt>,
  <tt>graph_chain</tt> returns the longest <i>chain</i> that starts at the
  vertex <tt>x</tt>, which is a path that is composed only of vertices of
  degree 2, except for the first vertex, <tt>x</tt>, which must be of degree 1,
  and the last vertex, which can be of any degree. If the first vertex,
  <tt>x</tt>, is of degree other than one, then the path will comprise only the
  vertex <tt>x</tt>.</p>

<p>Given a graph in neighbor list representation and two vertices <tt>x</tt>
  and <tt>p</tt>, <tt>graph_chain</tt> first removes any edge between the two
  vertices and then returns the longest chain that starts from vertex
  <tt>x</tt>.</p>

<p>Given a graph in neighbor list representation and two vertices <tt>a</tt>
  and <tt>b</tt>, <tt>graph_ear</tt> first removes any edge between the two
  vertices and then returns two paths: 1) the longest chain that starts from
  vertex <tt>a</tt> and 2) the longest chain that starts from vertex
  <tt>b</tt>. If the first path ends at vertex <tt>b</tt>, then the second path
  will comprise only the vertex <tt>b</tt>.</p>
<a id="graph_dfs2"></a>
<a id="graph_dfs1"></a>
<hr noshade="noshade" />

<pre>[dis, fin, par, low, cc] = <span class=
  "fcndef">graph_dfs1</span> nbrlist
[dis, fin, par, low, cc, tc, ebc, bc] = <span class=
"fcndef">graph_dfs2</span> nbrlist
</pre>

<p>Given a graph in neighbor list representation, functions
  <tt>graph_dfs1</tt> and <tt>graph_dfs2</tt> will calculate the vertex and
  edge labels associated with the <i>depth-first search</i> of the graph. These
  are utility routines that are used internally for calculating other graph
  properties.</p>
  <ul>
    <li><tt>dis(i)</tt> is the DFS discovery time of vertex <tt>i</tt>.</li>
    <li><tt>fin(i)</tt> is the DFS finishing time of vertex <tt>i</tt>.</li>
    <li><tt>par(i)</tt> is the DFS parent vertex of vertex <tt>i</tt>.</li>
    <li><tt>low(i)</tt> is the lowest DFS back-edge discovery time of vertex
    <tt>i</tt>.</li>
    <li><tt>cc(i)</tt> is the connected component ID of vertex <tt>i</tt>.</li>
    <li><tt>tc(i)</tt> is the tree component ID of vertex <tt>i</tt>.</li>
    <li><tt>ebc(i)</tt> is the edge-biconnected block ID of vertex
    <tt>i</tt>.</li>
    <li><tt>bc(i)(k)</tt> is the pure tree component ID or block ID of edge
    (<tt>i,j</tt>), where <tt>j=nbrlist(i)(k)</tt>.</li>
  </ul>

<p>Definitions:</p>
  <ul>
    <li>A <i>connected component</i> is a maximal subgraph that has every pair
    of vertices connected by some path.</li>
    <li>A <i>tree component</i> is a maximal subgraph that has every pair of
    vertices connected by exactly one path.</li>
    <li>A <i>block</i> is a maximal subgraph that has every pair of vertices
    connected by at least two paths.</li>
    <li>An <i>articulator</i> whose removal would disconnect the graph.</li>
    <li>A <i>block articulator</i> is a vertex that belongs to at least two
    different tree components or blocks.</li>
    <li>A <i>spiro articulator</i> is a vertex that belongs to at least two
    different blocks but no tree components.</li>
    <li>A <i>pure tree component</i> is a maximal subgraph that has every pair
    of vertices connected by exactly one path and no path contains any block
    articulator, except as its end vertices. Spiro articulators are considered
    to be pure tree components of size 1.</li>
    <li>An <i>edge-biconnected block</i> is a maximal subgraph that has every
    pair of vertices connected by at least two edge-disjoint paths, i.e. paths
    that may share some vertices but don&#39;t share any edges. This is
    equivalent to the ring block ID for the node, which is 0 if the node is not
    contained within any cycle, or &gt;&nbsp;0 if it is contained within at
    least one cycle. All nodes which are in the same ring block share the same
    <i>edge-biconnected block</i> value.</li>
  </ul>

<p>Block IDs are returned as positive integers, tree component IDs as
  negative integers (except for spiro articulators). Edge-biconnected blocks
  are assigned the ID of the first (minimum) block they comprise. Tree
  components are assigned the ID of the first (maximum) pure tree component
  they comprise. Spiro articulators assigned the ID of their edge-biconnected
  block.</p>

<p> <img src="graphlib/ringblocks.png" class="center" /></p>

<pre>
    svl&gt; nbrlist = [
            [2,11,3], [4,1], [1,6], [2,5], [4,9,6], [3,7,5],
            [10,8,6], [9,7], [8,5], 7, [12,1], [15,17,11],
            [14,15], [13,16], [13,12], [14,17], [16,12]
        ];
    svl&gt; rblk = (graph_dfs2 nbrlist)(7);
    svl&gt; print rblk
    [1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2]
</pre>
<a id="graph_ccomponent_list"></a>
<a id="graph_ccomponent"></a>
<hr noshade="noshade" />

<pre>compnum = <span class="fcndef">graph_ccomponent</span> nbrlist
list = <span class="fcndef">graph_ccomponent_list</span> nbrlist
</pre>

<p>Given a graph in neighbor list representation, function
  <tt>graph_ccomponent</tt> finds all connected components of the graph and
  returns the connected component ID of each vertex. Given a graph of <i>n</i>
  vertices with <i>c</i> connected components, the function returns an
  <i>n</i>-vector of integers in the range 1,2,...,<i>c</i>. Two vertices have
  the same component ID if and only if there is a path between them.</p>

<p>Function <tt>graph_ccomponent_list</tt> returns the list of connected
  components. Vector <tt>list(i)</tt> comprises all vertices of component
  <tt>i</tt>.</p>

<p>Each vertex is a member of only one connected component.</p>
<a id="graph_blockarticulator"></a>
<a id="graph_articulator"></a>
<a id="graph_eblock_list"></a>
<a id="graph_block_list"></a>
<a id="graph_block"></a>
<hr noshade="noshade" />

<pre>list = <span class="fcndef">graph_block</span> nbrlist
block = <span class="fcndef">graph_block_list</span> nbrlist
eblock = <span class="fcndef">graph_eblock_list</span> nbrlist
amask = <span class="fcndef">graph_articulator</span> nbrlist
amask = <span class="fcndef">graph_blockarticulator</span> nbrlist
</pre>

<p>Given edges of a graph in neighbor list representation, function
  <tt>graph_block</tt> finds all blocks (biconnected components) of the graph
  and replaces each edge in the neighbor list with its the block or pure tree
  component ID (see <tt>graph_dfs2</tt> for details). Blocks are assigned
  positive IDs, tree components, negative IDs.</p>

<p>Function <tt>graph_block_list</tt> returns the list of all blocks. Vector
  <tt>block(i)</tt> comprises all vertices of block <tt>i</tt>.</p>

<p>Function <tt>graph_eblock_list</tt> returns the list of all
  edge-biconnected blocks. Vector <tt>eblock(i)</tt> comprises all vertices of
  the <tt>i</tt>-th edge-biconnected block.</p>

<p>Function <tt>graph_articulator</tt> returns the mask of all
  articulators.</p>

<p>Function <tt>graph_blockarticulator</tt> returns the mask of all block
  articulators.</p>

<p>Each vertex may be a member of more than one block. Each vertex is a
  member of at most one edge-biconnected block.</p>
<a id="graph_triblock_list"></a>
<hr noshade="noshade" />

<pre>list = <span class="fcndef">graph_triblock_list</span> nbrlist
</pre>

<p>Given edges of a graph in neighbor list representation,
  <tt>graph_triblock_list</tt> returns the list of all triconnected blocks.
  Vector <tt>list(i)</tt> comprises all vertices of triblock <tt>i</tt>.</p>

<p>A <i>triconnected block</i> is a maximal subgraph with each pair of
  vertices connected by at least three (vertex-disjoint) paths. For example, a
  cube is a triconnected graph.</p>
<a id="graph_connector"></a>
<hr noshade="noshade" />

<pre>con = <span class="fcndef">graph_connector</span> [nbrlist, m]
</pre>

<p>Given edges of a graph in neighbor list representation and a mask defining
  a set of vertices, <tt>graph_connector</tt> finds the <i>connecting
  vertices</i>: the union of all paths connecting any two vertices from the
  given set. If the given vertices belong to the same connected component, the
  function returns the mask of the connecting vertices. If the given vertices
  belong to several different connected components, the function returns a
  vector of vertex labels, where the connecting vertices of the same component
  are labeled with the same positive number and all non-connecting vertices are
  labeled with zero.</p>
<a id="graph_sconnector"></a>
<hr noshade="noshade" />

<pre>
con = <span class="fcndef">graph_sconnector</span> [nbrlist, m]
</pre>

<p>Given edges of a graph in neighbor list representation and a mask defining
  a set of vertices, <tt>graph_sconnector</tt> finds the union of all shortest
  paths connecting any two vertices from the given set. If the given vertices
  belong to the same connected component, the function returns the mask of the
  connecting vertices. If the given vertices belong to several different
  connected components, the function returns a vector of vertex labels, where
  the connecting vertices of the same component are labeled with the same
  positive number and all non-connecting vertices are labeled with zero.</p>

<p>The function is similar to function <tt>graph_connector</tt>. However, on
  inputs that require connecting many vertices of large cycle components, it
  can be significantly slower than function <tt>graph_connector</tt>.</p>

<p>On the connecting cycle components of the graph, function
  <tt>graph_sconnector</tt> returns only those vertices that lie on a
  connecting shortest path, while function <tt>graph_connector</tt> returns all
  vertices of the component. On the connecting tree components of the graph,
  the outputs of functions <tt>graph_connector</tt> and
  <tt>graph_sconnector</tt> are identical.</p>
<a id="graph_bfspath"></a>
<a id="graph_bfs"></a>
<hr noshade="noshade" />

<pre>
[dis, par, depth, cc] = <span class="fcndef">graph_bfs</span> nbrlist
mpath = <span class="fcndef">graph_bfspath</span> [nbrlist, src, dst, maxdepth]
</pre>

<p>Given a graph in neighbor list representation, functions
  <tt>graph_bfs</tt> and <tt>graph_bfspath</tt> will traverse the graph using
  the <i>breadth-first search</i> traversal. These are utility routines that
  are used internally for calculating other graph properties.</p>

<p>Function <tt>graph_bfs</tt> will calculate the vertex labels associated
  with the breadth-first search:</p>
  <ul>
    <li><tt>dis(i)</tt> is the BFS discovery time of vertex <tt>i</tt>. The
    discovery times are consecutive integers, starting from 1.</li>
    <li><tt>par(i)</tt> is the BFS parent vertex of vertex <tt>i</tt>. The
    parent of the root vertex is 0.</li>
    <li><tt>depth(i)</tt> is the BFS depth vertex <tt>i</tt>. The root vertex
    of each component has depth 1.</li>
    <li><tt>cc(i)</tt> is the connected component ID of vertex <tt>i</tt>. The
    component IDs are consecutive integers, starting from 1.</li>
  </ul>

<p>Function <tt>graph_bfspath</tt> returns the graph vertices in the
  breadth-first search order, starting from the given set of vertices,
  <tt>src</tt>. The output vertices are split to lists of vertices of the same
  depth. The traversal is terminated if it reaches a destination vertex from
  <tt>dst</tt> or if it reaches the maximum depth, <tt>maxdepth</tt>. A missing
  <tt>maxdepth</tt> argument is equivalent to infinity. Vector
  <tt>mpath</tt>(<i>k</i>) will contain all vertices of distance <i>k</i>-1
  from <tt>src</tt>.</p>
<a id="graph_scycle"></a>
<a id="graph_spath2"></a>
<a id="graph_spath"></a>
<hr noshade="noshade" />

<pre>
mpath = <span class="fcndef">graph_spath</span> [nbrlist, [a, b]]
mpath = <span class="fcndef">graph_spath2</span> [nbrlist, [a, b]]
mpath = <span class="fcndef">graph_scycle</span> [nbrlist, [a, b]]
</pre>

<p>Given edges of a graph in neighbor list representation and two sets of
  vertices <tt>a</tt> and <tt>b</tt>, <tt>graph_spath</tt> returns vertices on
  all shortest paths from <tt>a</tt> to <tt>b</tt>. Vector
  <tt>mpath</tt>(<i>k</i>) will contain all vertices of distance <i>k</i>-1
  from <tt>a</tt> and of distance <i>m-k</i> from <tt>b</tt>, where
  <i>m</i>=<tt>length&nbsp;mpath</tt>. Function <tt>graph_spath</tt> returns
  the shortest paths between the vertices of <tt>a</tt> closest to <tt>b</tt>
  and the vertices of <tt>b</tt> closest to <tt>a</tt>. In other words, only
  the first vertex of each shortest path belongs to <tt>a</tt> and only the
  last vertex of each path belongs to <tt>b</tt>. Some vertices from <tt>a</tt>
  or <tt>b</tt> may not belong to any path.</p>

<p>Given edges of a graph in neighbor list representation and two sets of
  vertices <tt>a</tt> and <tt>b</tt>, <tt>graph_spath2</tt> returns vertices on
  all shortest paths from <tt>a</tt> to each element of <tt>b</tt>. Vector
  <tt>mpath</tt>(<i>k</i>) will contain all vertices of distance <i>k</i>-1
  from <tt>a</tt> and of distance <i>m-k</i> from some element of <tt>b</tt>,
  where <i>m</i>=<tt>length&nbsp;mpath</tt>. Function <tt>graph_spath2</tt>
  returns the shortest paths between the vertices of <tt>a</tt> closest to
  <tt>b</tt> and all vertices of <tt>b</tt> regardless their distance to
  <tt>a</tt>. In other words, only the first vertex of each shortest path
  belongs to <tt>a</tt> and some vertices from <tt>a</tt> may not belong to any
  path. However, each vertex from <tt>b</tt> belongs to some path, even though
  it may not always be the last vertex of the path.</p>

<p>Given edges of a graph in neighbor list representation and an edge,
  (<tt>a,b</tt>), <tt>graph_scycle</tt> returns vertices of all shortest cycles
  incident to that edge. The function first removes the given edge
  (<tt>a,b</tt>) from the graph and then returns all shortest paths from
  <tt>a</tt> to <tt>b</tt> in the same format given by function
  <tt>graph_spath</tt>.</p>
<a id="graph_canonize_cycles"></a>
<a id="graph_firstpath"></a>
<a id="graph_npaths"></a>
<a id="graph_expandpaths"></a>
<hr noshade="noshade" />

<pre>
list = <span class="fcndef">graph_expandpaths</span> [nbrlist, mpath]
npaths = <span class="fcndef">graph_npaths</span> [nbrlist, mpath]
path = <span class="fcndef">graph_firstpath</span> [nbrlist, mpath]
list = <span class="fcndef">graph_canonize_cycles</span> list
</pre>

<p>Given the result of the previous functions, <tt>graph_expandpaths</tt>
  expands the implicit paths and returns a list of explicit paths. Given
  <i>m</i> lists of vertices, <tt>mpath</tt>, the function returns the list of
  all paths, <tt>list</tt>, such that vertex <tt>list(i)</tt>(<i>k</i>) belongs
  to <tt>mpath</tt>(<i>k</i>), for all <i>k</i>=1,2,...<i>m</i>.</p>

<p>In some cases, the paths returned by function <tt>graph_expandpaths</tt>
  may be too numerous and prohibitive in computer resources to calculate
  explicitly. For example, the number of shortest paths that traverse an N-unit
  polysaccaride is 2<sup>N</sup>. Functions <tt>graph_npaths</tt> and
  <tt>graphs_firstpath</tt> allow the user to avoid calling the function
  <tt>graphs_expandpaths</tt> in certain common cases.</p>

<p>Function <tt>graph_npaths</tt> returns the size of the result of function
  <tt>graph_expandpaths</tt>, i.e. the number of all possible paths, without
  generating the paths explicitly. The calculation is fast even when the number
  of paths is extremely large.</p>

<p>Function <tt>graph_firstpath</tt> returns the first path returned by
  function <tt>graph_expandpaths</tt>. The calculation is fast even when the
  number of paths is extremely large.</p>

<p>Given a list of cycles, with each cycle represented by a list of vertices,
  <tt>graph_canonize_cycles</tt> will rotate and/or reverse each cycle (list of
  vertices) to its <i>canonical</i> form, defined here as the lexicographically
  first of all orderings of the cycle vertices. That is, the smallest vertex is
  listed first and the smaller of its neighbors is listed second.</p>
<a id="graph_scycle_list"></a>
<hr noshade="noshade" />

<pre>[list1, list2, list3] = <span class=
  "fcndef">graph_scycle_list</span> nbrlist
</pre>

<p>Given edges of a graph in neighbor list representation,
  <tt>graph_scycle_list</tt> returns three lists of selected shortest cycles.
  The first list, <tt>list1</tt>, contains all cycles that are the unique
  shortest cycle with respect to one of their edges. The second list,
  <tt>list2</tt>, contains all cycles that are one of exactly two shortest
  cycles with respect to one of their edges and that don&#39;t already belong
  to <tt>list1</tt>. The third list, <tt>list3</tt>, contains a minimal list of
  the remaining shortest cycles that are needed to cover all cycle edges in the
  graph.</p>

<p>For example, given the graph of the indole molecule
  (<tt>&quot;c12c([nH]cc1)cccc2&quot;</tt>), the function returns both the
  5-element pyrrole ring and the 6-element benzene ring in <tt>list1</tt>.
  However, given the graph of the <tt>C<sub>60</sub></tt> fullerene, the
  function returns only the 5-element rings in <tt>list1</tt>, while the
  6-element rings are returned in <tt>list2</tt>. Given the molecule
  <tt>&quot;C1COCCN2CCOCCOCCN(CCO1)CCc3ccc(CC2)cc3&quot;</tt>, the function
  returns only the 6-element benzene ring in <tt>list1</tt>, while two of the
  five possible (shortest) 18-element rings are returned in <tt>list3</tt>.</p>
<a id="graph_hyperneighbors"></a>
<a id="graph_cycleneighbors"></a>
<hr noshade="noshade" />

<pre>nbrlist = <span class="fcndef">graph_cycleneighbors</span> clist
nbrlist = <span class="fcndef">graph_hyperneighbors</span> hlist
</pre>

<p>Given a list of <i>n</i> cycles, <tt>graph_cycleneighbors</tt> returns the
  neighbor list representation of a graph
  <i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>), such that the edge
  (<i>u</i>,<i>v</i>) belongs to <i>E</i> if and only if cycles
  <tt>clist(</tt><i>u</i><tt>)</tt> and <tt>clist(</tt><i>v</i><tt>)</tt> share
  an edge.</p>

<p>Given a list of <i>n</i> cycles, <tt>graph_hyperneighbors</tt> returns the
  neighbor list representation of a graph
  <i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>), such that the edge
  (<i>u</i>,<i>v</i>) belongs to <i>E</i> if and only if cycles
  <tt>hlist(</tt><i>u</i><tt>)</tt> and <tt>hlist(</tt><i>v</i><tt>)</tt> share
  a vertex. However, <tt>graph_hyperneighbors</tt> can be given not only a list
  of graph cycles, but also a list of arbitrary sets, representing the
  (hyper)edges of a <i>hypergraph</i>.</p>

<p>In a graph, each edge is incident to exactly two vertices. In a
  <i>hypergraph</i>, each <i>hyperedge</i> can be incident to more than two
  vertices. The set comprising the IDs of all hyperedges that are incident to
  vertex <i>a</i> is called the <i>incidence list</i> of vertex <i>a</i>.</p>

<p>Given a list of <i>n</i> incidence lists (i.e. arbitrary sets),
  <tt>graph_hyperneighbors</tt> returns the neighbor list representation of a
  hypergraph <i>G</i>=(<i>V</i>=1..<i>n</i>,&nbsp;<i>E</i>), such that the
  hyperedge <span class="nobr">(<i>u</i><sub>1</sub>, <i>u</i><sub>2</sub>,
  ...)</span> belongs to <i>E</i> if and only if the incidence lists (sets)
  <span class="nobr">{<tt>hlist(</tt><i>u</i><sub>1</sub><tt>)</tt>,
  <tt>hlist(</tt><i>u</i><sub>2</sub><tt>)</tt>, ...}</span> intersect.</p>
<a id="graph_walkclass"></a>
<hr noshade="noshade" />

<pre>cnum = <span class="fcndef">graph_walkclass</span> [nbrlist, label]
</pre>

<p>Given an undirected graph in neighbor list representation and a label for
  each vertex, <tt>graph_walkclass</tt> returns an integer for each vertex such
  that two vertices have the same returned integer if and only if the set of
  all walks emanating from one vertex is identical to the other. In other
  words, <tt>graph_walkclass</tt> determines walk-symmetric vertices. Note:
  <tt>graph_walkclass</tt> detects isomorphic vertices only with respect to
  walks; there are graphs for which vertices are walk-isomorphic but not
  generally isomorphic.</p>
<a id="graph_shortestpath"></a>
<hr noshade="noshade" />

<pre>path = <span class=
  "fcndef">graph_shortestpath</span> [nbrlist, src, dst]
</pre>

<p>Given an undirected graph in neighbor list representation and a label for
  each vertex, <tt>graph_shortestpath</tt> returns an ordered list of vertex
  numbers detailing the shortest path from the <tt>src</tt> vertex to the
  <tt>dst</tt> vertex. The first element of the returned path is <tt>src</tt>
  and the last is <tt>dst</tt>. Null is returned if there is no path from
  <tt>src</tt> to <tt>dst</tt>.</p>
<a id="graph_maxmatch"></a>
<hr noshade="noshade" />

<pre>mask = <span class="fcndef">graph_maxmatch</span> [xA, xB, weight]
</pre>

<p>Given an edge list representation <tt>[xA,xB]</tt> of an undirected graph
  and a set of non-negative numeric weights such that <tt>weight(i)</tt> is the
  weight of edge (<tt>xA(i)</tt>,<tt>xB(i)</tt>), <tt>graph_maxmatch</tt>
  returns a mask such that <tt>mask(i)</tt> is one if edge <tt>i</tt> is in the
  matching of maximum weight and zero otherwise. A <i>matching</i> is a subset
  of non-adjacent edges and a maximal matching is a matching in which all
  unmatched edges are adjacent to a matched edge. The return matching is such
  that <span class="nobr"><tt>add (weight|mask)</tt></span> is maximized. Note:
  the calculation is performed with 30 bits of precision for the weight.
  <!-- =========== automorphism =========== --></p>
<a id="graph_automorphism_close"></a>
<a id="graph_automorphism_next"></a>
<a id="graph_automorphism_open"></a>
<hr noshade="noshade" />

<pre>autokey = <span class=
  "fcndef">graph_automorphism_open</span> [nbrlist, label]
idx = <span class="fcndef">graph_automorphism_next</span> autokey
<span class="fcndef">graph_automorphism_close</span> autokey
</pre>

<p>The <tt>graph_automorphism</tt> functions are used in tandem to calculate
  all of the automorphisms of a labeled graph. A graph automorphism is a
  permutation of the vertex labels that preserves edge connectivity. The three
  functions are typically used as follows:</p>

<pre>    local key = graph_automorphism_open [nbrlist, label]
    local idx;

    while length (idx = graph_automorphism_next key) loop
        // each vertices[idx] is an edge conserving vertex permutation
    endloop

    graph_automorphism_close key;
</pre>

<p>Note that the SVL <tt>dmatch</tt> functions are used calculate the
  automorphisms; therefore, the given graph should not be very large otherwise
  prohibitively large resources may be required.</p>

<h1>See Also</h1>

<p><a href="dmatch.htm">Distance Geometry Matching Functions</a><br />
  <a href="../../moe/fcnref/bondlist.htm">Atom Functions</a>
  </p>
<!-- START MOE_FOOTER -->
  <div class="MOE_FOOTER">
    <img src="../../images/ccgicon.png" /> <a href="../../index.htm"></a>
    <a href="../../legal.htm"></a> &copy;<span class="versionyear"></span>
    <a href="http://www.chemcomp.com"></a>. All rights reserved.<br />
    <a href="mailto:info@chemcomp.com"></a>
  </div><!-- END MOE_FOOTER -->
</div>
</div>
</body>
</html>

