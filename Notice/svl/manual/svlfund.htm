<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="x-ua-compatible" content="IE=9" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" type="text/css" href="../../include/manstyle.css" />
  <link rel="icon" type="image/png" href="../../images/ccgicon.png" />
  <link rel="shortcut icon" type="image/png" href="../../images/ccgicon.png" />
  <title>Fundamental SVL Concepts</title>
</head>
<body>
<div class="center-page">
  <!-- START MOE_HEADER -->
  <div class="MOE_HEADER">
    <a href="../../index.htm"><img src="../../images/ccglogo.png" /></a>
    <a href="../../index.htm"><div class="moeversion"></div></a>
    Fundamental SVL Concepts
  </div>
<!-- END MOE_HEADER -->
<div class="content">

<p>[<a href="intro.htm">Previous Chapter</a>] [<a href="data.htm">Next
  Chapter</a>] [<a href="index.htm">Table of Contents</a>]</p>
  <ul>
    <li>
      <a href="#VectorsAndVectorNotation">Vectors and Vector Notation</a>
      <ul>
        <li><a href="#UnitVectors">Unit Vectors</a></li>
        <li><a href="#Scalars">Scalars</a></li>
      </ul>
    </li>
    <li><a href="#UnitExtension">Unit Extension</a></li>
    <li>
      <a href="#Fundamental_Data_Types">Fundamental Data Types</a>
      <ul>
        <li><a href="#NumericData">Numeric Data</a></li>
        <li><a href="#CharacterData">Character Data</a></li>
        <li><a href="#TokenData">Token Data</a></li>
        <li><a href="#TypeConversions">Type Conversions</a></li>
      </ul>
    </li>
    <li><a href="#VectorSyntax">Vector Syntax</a></li>
    <li><a href="#Nesting">Nesting</a></li>
    <li>
      <a href="#IndexingandTagging">Vector Elements: Indexing and Tagging</a>
      <ul>
        <li><a href="#Indexing">Indexing</a></li>
        <li><a href="#Tagging">Tagging</a></li>
      </ul>
    </li>
    <li>
      <a href="#SVLFunctions">SVL Functions</a>
      <ul>
        <li><a href="#FunctionExtension">Function Extension</a></li>
        <li><a href="#Operators">Operators</a></li>
        <li><a href="#UnaryOperators">Unary Operators</a></li>
        <li><a href="#BinaryOperatorsAndReduction">Binary Operators and
        Reduction</a></li>
        <li><a href="#LexicographicAndElementWiseOperators">Lexicographic and
        Element-wise Operators</a></li>
        <li><a href="#StructuralFunctions">Structural Functions</a></li>
        <li><a href="#PrimaryDataAccessFunctions">Primary Data Access
        Functions</a></li>
        <li><a href="#m_-typeAndx_-typeFunctions">m_-type and x_-type
        Functions</a></li>
        <li><a href="#ClassificationOfStructuralFunctions">Classification of
        Structural Functions</a></li>
      </ul>
    </li>
    <li><a href="#HowCLICommandsAreExecuted">How CLI Commands Are
    Executed</a></li>
    <li><a href="#Built-inConstants">Built-in Constants</a></li>
  </ul>

<p>SVL is a collection-oriented language. This means that it acts on
  collections or aggregates of data as a whole rather on single data items. The
  SVL collection is the <i>vector</i>, a quantity very much like the array that
  is found in many programming languages; i.e. a random-access collection of
  values. A vector is a list of objects. These objects are labeled and referred
  to by either <i>indices</i> or <i>tags</i>. Each vector has a particular
  <i>shape</i> or <i>conformation</i>, characterized by its length, and the
  length and levels of nesting of its elements.</p>

<h1>
<a id="VectorsAndVectorNotation">Vectors
  and Vector Notation</a></h1>

<p>The basic unit of data in SVL is the vector. A vector is denoted by
  brackets ([]) and its elements are separated by commas. For example:</p>

<pre>
    [2,3,4]
</pre>

<p>is a vector with three elements.</p>

<p>The general ordered vector has the form:</p>

<pre>
    x = [ x<sub>1</sub>, ... , x<sub>n</sub> ].
</pre>

<p>Each x<sub>i</sub> is called an <i>element</i> of x, and <i>n</i> is the
  length of x. In turn, each element <i>x<sub>i</sub></i> may be a vector
  itself. Vectors can nest to arbitrary depths. If <i>n</i> = 0, then x is a
  <i>null vector</i>, and if <i>n</i> = 1, then x is called a <i>unit
  vector</i>. All vectors are constructed from the set of <i>atomic unit
  vectors</i> (characters, numbers, etc.) and null vectors.</p>

<p>There are 2 cases in which the brackets may be omitted, as a kind of
  shorthand:</p>
  <ul>
    <li>Scalars</li>
    <li>Strings, where double quotes are used instead</li>
  </ul>

<h1><a id="UnitVectors">Unit Vectors</a></h1>

<p>A vector of length 1 is called a <i>unit vector</i>. It is important to
  understand what constitutes a unit vector since the concept of <i>unit
  extension</i> depends on unit vectors. Here are some examples of unit
  vectors:</p>

<pre>
    3
    [ [1,2] ]
    [ [ 1, [2,3] ] ]
    [ &quot;abc&quot; ]
</pre>

<p>These are <b>not</b> unit vectors:</p>

<pre>
    [1, 2]
    &quot;abc&quot;
</pre>

<h1><a id="Scalars">Scalars</a></h1>

<p>Scalars are vectors that contain a single value of a basic data type, such
  as a number or a character.</p>

<p>Scalars can be written with or without enclosing brackets. Moreover,
  because they are infinitely nestable, a scalar enclosed with any number of
  brackets is equivalent to its unbracketed form.  This property means
  that a scalar can <a href="#UnitExtension"><i>unit-extend</i></a>
  at any level of nesting.
  </p>

<p>The following are examples of scalars:</p>

<pre>
    1
    'token'
    &quot;0&quot;
    [ 'a' ]
    [[&quot;a&quot;]]
    [[[[1.3]]]]
    ''           // null token
</pre>

<p>The following are <b>not</b> scalars:</p>

<pre>
    []
    [ [] ]
    &quot;&quot;
    [1,2]
    [ [1,2] ]
    &quot;ab&quot;
</pre>

<p>A <i>scalar</i> has the property:</p>

<pre>
    a === [a]
</pre>

<p>Note: although scalars are unit vectors, not all unit vectors are
  scalars.</p>

<h1><a id="UnitExtension">Unit Extension</a></h1>

<p>SVL operations on two vectors generally proceed element-wise, i.e. by
  pairing an element from one operand with the corresponding element in the
  other operand. In general, the vectors must be of equal length. However, if
  one of them is a <i>unit</i>, it is automatically replicated to the length
  of the other argument. The mechanism to do this is called
  <i>unit extension</i>.
</p>

<p>Unit extension is illustrated in the following examples.</p>

<pre>
    svl&gt; 1 + [2,3]             // 1 extends to [1,1]
    [3,4]

    svl&gt; 1 + [ 2, [3,4] ]      // 1 extends to [ 1, [1,1] ]
    [ 3, [4,5] ]

    svl&gt; [1,2] + [ 3, [4,5] ]  // 2 extends to [2,2]
    [ 4, [6,7] ]

    svl&gt; print 2 + []          // 2 extends to []
    []

    svl&gt; [2,3,4] * [ [5,6,7] ] // outer product
    [ [10,12,14], [15,18,21], [20,24,28] ]
</pre>

<p>We used the command <tt>print</tt> in the third example to make sure the
  result (the empty vector, <tt>[]</tt>) gets printed. By default, the empty
  vector would not get printed in the CLI.</p>

<p>In the last example, <tt>[[5,6,7]]</tt> is the unit, which extends to each
  element of the vector on the left.</p>

<p>Not all functions unit extend their arguments at all levels of nesting.
  Some functions unit extend at the top level only while others do not unit
  extend at all.</p>

<h1><a id="Fundamental_Data_Types">Fundamental
  Data Types</a></h1>

<p>When we discuss fundamental data types, we are looking at the different
  types of <i>literal constants</i> that can be defined. A literal constant is
  an object whose value cannot be changed (constant), and which can only be
  discussed in terms of its value (literal). There are 3 types: <i>numeric</i>,
  <i>character</i> and <i>token</i>.</p>

<h2><a id="NumericData">Numeric Data</a></h2>

<p>Numeric literals can be either integer or floating point. However, in
  normal usage, all numeric data is manipulated in floating point
  representation, so that this distinction is unimportant. However, integer
  operations (e.g. <tt>even</tt> and <tt>bitand</tt>) expect integers, and are
  not well defined for real arguments. The precision of floating point
  representation is machine dependent, and you will have to consult your system
  documentation to determine what the precision is for your particular
  set-up.</p>

<p>For information on how to determine the numerical limits of your machine
  see <a href="#Built-inConstants">Built-in Constants</a>.</p>

<p>Explicit integer operations do exist, but we recommend that, in general,
  you use the default floating-point representation for your calculations.</p>

<p>An integer has absolute value less than 2<sup>31</sup>-1. Integers any
  larger than this become floating-point quantities. Floating point or
  <i>real</i> numbers may be written with or without a decimal point, and may
  be written in exponential notation. They are stored as IEEE double-precision
  numbers.</p>

<p><b>Note:</b> Numbers must begin with a digit. They cannot begin with
  either <tt>e</tt> or the decimal point.</p>

<p>These are examples of numeric data:</p>

<pre>
    0
    0.3
    3.
    -2.718e-4
    3.1415E10
</pre>

<p>Hexadecimal numbers are indicated by the prefix <tt>0x</tt>
  (zero-lowercase x).</p>

<pre>
    0x10 // 16
</pre>

<p>It is possible to explicitly force integer arithmetic for purposes of
  performance.</p>

<h2><a id="CharacterData">Character Data</a></h2>

<p>Character data is indicated by the presence of &quot;double quotes.&quot;
  Often, character data is aggregated into strings. A <i>string</i> is a
  <i>flat</i> vector of characters that can be written using a shorthand that
  puts all the characters of the string inside one set of double quotes; e.g.
  <tt>[&nbsp;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</tt>
  is the same as <tt>&quot;abcd&quot;</tt>. A flat vector has only scalar
  elements.</p>

<p>Note the following:</p>

<pre>
    svl&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;cd&quot; ] // not the same as &quot;abcd&quot;
    [ &quot;a&quot;, &quot;b&quot;, &quot;cd&quot; ]
    svl&gt; [ &quot;abcd&quot; ]      // not the same as &quot;abcd&quot;
    [ &quot;abcd&quot; ]
    svl&gt; [ 'abcd' ]      // compare to token
    'abcd'
</pre>

<p>Observe that the third element of <tt>[ &quot;a&quot;, &quot;b&quot;,
  &quot;cd&quot; ]</tt> is itself a character vector containing 2 elements.</p>

<p><b>Caution!</b> Double quotes should not be considered an alternative to
  brackets for delimiting vectors. Unlike brackets, double quotes cannot be
  nested:</p>

<pre>
    svl&gt; &quot;&quot;a&quot;&quot; // error!
</pre>

<p>String literals may not straddle line boundaries, that is, they must fit
  on one line. There is no string continuation character that permits
  multi-line literals. However, strings separated by white space (blanks, tabs,
  newlines) are automatically concatenated into a single string. For
  example,</p>

<pre>
    svl&gt; &quot;sit&quot; &quot;e&quot;
</pre>

<p>and</p>

<pre>
    print &quot;sit&quot; // in a function
          &quot;e&quot;;
</pre>

<p>both yield:</p>

<pre>
    &quot;site&quot;
</pre>

<p>Selected characters can be specified using the backslash (<tt>\</tt>). For
  example, the backslash is used for including a double quote character in a
  string: (<tt>\&quot;</tt>). To generate the backslash character itself, use
  double backslash (<tt>\\</tt>).</p>
  <table class="titlebar">
    <tr>
      <th>sequence</th>
      <th>character</th>
    </tr>
    <tr>
      <td><tt>\n</tt></td>
      <td>newline</td>
    </tr>
    <tr>
      <td><tt>\t</tt></td>
      <td>horizontal tab</td>
    </tr>
    <tr>
      <td><tt>\&quot;</tt></td>
      <td>double quote</td>
    </tr>
    <tr>
      <td><tt>\'</tt></td>
      <td>single quote</td>
    </tr>
    <tr>
      <td><tt>\\</tt></td>
      <td>backslash</td>
    </tr>
  </table>

<p>Note that generalized escape sequences of the form</p>

<pre>
    \ooo
</pre>

<p>are permitted, where <tt>ooo</tt> represents up to three octal digits.
  These octal digits give the numerical value of a character in the ASCII
  character set.</p>

<pre>
    svl&gt; &quot;\101&quot;
    &quot;A&quot;
</pre>

<p>These numerical values can also be expressed in hexadecimal using the
  escape sequence <tt>\x</tt>. For example,</p>

<pre>
    svl&gt; &quot;\x65&quot;
    &quot;e&quot;
</pre>

<p>Here are some examples of valid string literals:</p>

<pre>
    &quot;\&quot;Hello\n How are you?\&quot;&quot;
    &quot;file1.svl&quot;
    &quot;!\@\#\$\%\ *()_+|&quot;
</pre>

<p>The null string <tt>&quot;&quot;</tt> is the null vector, which can also
  be written as <tt>[]</tt>.</p>

<h2><a id="TokenData">Token Data</a></h2>

<p>Tokens are sequences of characters enclosed in 'single quotes.' As
  with string literals, token literals cannot straddle line boundaries. Like
  strings, tokens separated by white space (blanks, tabs, newlines) are
  automatically concatenated into a single token. For example,</p>

<pre>
    svl&gt; 'to' 'me'
</pre>

<p>becomes:</p>

<pre>
    'tome'
</pre>

<p>Tokens may also contain characters specified using codes preceded by
  backslash (see previous table). The single quote character is generated using
  two-character combination of a backlash and single quote
  (<tt>\'</tt>).</p>

<p>Tokens are fundamentally different from strings: strings are vectors
  containing one or more elements; all tokens are unit vectors; in fact, they
  are scalars. Thus, the individual characters of strings can be compared and
  extracted, but those of tokens cannot.</p>

<p>Some valid SVL tokens:</p>

<pre>
    'Error message #4'
    'The vampire\'s kiss\n was somniferous.'
</pre>

<p>The null token (<tt>''</tt>) is <i>not</i> the null vector
  (<tt>[]</tt>). The null token is a scalar.</p>

<h2><a id="TypeConversions">Type Conversions</a></h2>

<p>Explicit type conversion is required to turn one type of data into
  another. The SVL conversion functions are:</p>

<pre>
    int real string token
</pre>

<p>Below are some examples of their usage. Note that <tt>string</tt> works
  only on scalars, and <tt>token</tt> operates only on flat vectors (i.e. on
  one string at a time).</p>

<pre>
    svl&gt; string 'abc def'
    &quot;abc def&quot;
    svl&gt; string [ 'abc', 'def' ] // error!
    svl&gt; token &quot;hat&quot;
    'hat'
    svl&gt; token [ &quot;hat&quot;, &quot;abc&quot; ] // error!
</pre>

<p><tt>token</tt> behaves much the same as <tt>string</tt>, except it returns
  tokens instead of strings.</p>

<p><tt>int</tt> and <tt>real</tt> only operate on numeric data, and are for
  specifying explicit data representation in memory. These 2 functions are
  generally not needed in the normal course of computations.</p>

<h1><a id="VectorSyntax">Vector Syntax</a></h1>

<p>The formal syntax of a vector is as follows:</p>

<pre>
    [ <i>expr</i>, ... , <i>expr</i> ]
</pre>

<p>where <i>expr</i> is an identifier, an expression, or a <i>null</i>
  (<tt>[]</tt>). In the latter case, the null must be explicitly written, as
  in, for example,</p>

<pre>
    [ 2, 3, [] , 4]
</pre>

<p>This kind of construct is useful for passing arguments to functions. In
  this case, a vector of known structure can be passed to a function that
  expects values in specified locations in the vector. Thus, only certain
  values are assigned to local variables. For instance, in the function
  definition:</p>

<pre>
    function do_something [ a, b, [] , c, d ]
        ...
    endfunction
</pre>

<p>The function expects a vector of 5 elements, only 4 of which are used in
  the function (if the vector passed to the function is longer than five
  elements, the additional elements are ignored).</p>

<p>The elements of a vector may be vectors themselves.</p>

<pre>
    [ 1, [2,3] ]
    [ 1, [ 2, [3,4] ] ]
</pre>

<p>They may in fact be any kind of expression, including assignments, which
  can be nested, as, for example, in:</p>

<pre>
    [ 1, a=2 ] // a=2
    [ 1, a = [ b = [2,3,4] ] ] // a=[ [2,3,4] ] b=[2,3,4]
</pre>

<h1><a id="Nesting">Nesting</a></h1>

<p>SVL vectors can be nested. In other words, a vector can contain another
  vector. We count the levels of nesting from the vector's <i>top
  level</i>. The top level of a vector comprises objects that are enclosed by
  the outermost set of vector delimiters. The <i>first level</i> of nesting
  refers to the objects belonging to the top-level elements, and so forth. The
  <i>leaf level</i> is the earliest (closest to top) level of nesting in which
  all the elements are scalars. When the top level and the leaf level are one
  and the same, as in <tt>[1,2,'a',&quot;b&quot;]</tt>, a vector is
  referred to as being <i>flat</i>.</p>

<pre>
    [ [ 1, [3,4] ], [ &quot;a&quot;, ['a', 2] ] ]
      [ 1, [3,4] ] [ &quot;a&quot;, ['a', 2] ] top level elements
      1 [3,4] &quot;a&quot; ['a', 2] first nesting level
      1 3 4 &quot;a&quot; 'a' 2 second nesting level
                                (leaf level)
      1 3 4 &quot;a&quot; 'a' 2 subsequent levels
                                are identical
</pre>

<p>Observe that scalars continue to exist through all levels of nesting. This
  is due to the arbitrary nestability of scalar quantities, as was discussed in
  <a href="#Scalars">Scalars</a>.</p>

<h1><a id="IndexingandTagging">Vector Elements:
  Indexing and Tagging</a></h1>

<p>Vectors can be treated as either ordered or unordered lists. In the former
  case, each element has an associated numerical <i>index</i> or
  <i>subscript</i>, in the latter, each element is <i>tagged</i> or
  <i>keyed</i>.</p>

<h2><a id="Indexing">Indexing</a></h2>

<p>When vectors are untagged, they are ordered lists. Elements are
  consecutively numbered from left to right, beginning at 1. These indices can
  be generated using the index generator <tt>x_id</tt>. The largest index gives
  the length of the vector, which can also be found using the
  <tt>length</tt>.</p>

<p>Indices need not be numbers, but can also be expressions, such as
  <tt>a+3</tt> or <tt>x(1)</tt>. Indices less than 1, i.e. 0 and negative
  numbers, are never valid, and any attempt to access vector elements using
  indices less than 1 will always result in an error. However, it <i>is</i>
  permissible to access elements whose indices are greater than the length of
  the vector, that is, elements beyond the end of the vector. These elements
  are nulls <tt>[]</tt>.</p>

<p>See <a href="#PrimaryDataAccessFunctions">primary data access
  functions</a> for more on accessing indexed elements and elements beyond the
  end of a vector.</p>

<h2><a id="Tagging">Tagging</a></h2>

<p>Vector elements can be <i>tagged</i>. A tagged vector has the form:</p>

<pre>
    [ tok:opt, ..., tok:opt ]
</pre>

<p>where <tt>tok</tt>, the tag, is an identifier (a token) undelimited by
  single quotes, double quotes, or brackets, and where <tt>opt</tt>, the tagged
  field, also called an <i>option field</i>, is an expression. Together, a tag
  and its field are known as an <i>attribute-value pair</i>. This is also known
  as an <i>options</i> construct. A tag is separated from its field by a colon
  (<tt>:)</tt>. The dot operator <tt>.</tt>, shorthand for <tt>tagpeek</tt>, is
  used to access a tagged field. For example:</p>

<pre>
    svl&gt; v = [ hey:3, ho:&quot;hello&quot; ]
    svl&gt; v.ho
    &quot;hello&quot;
    svl&gt; v.ho = 'good-bye'; v
    [ hey:3, ho:'good-bye' ]
    svl&gt; tagpeek [ v, 'hey' ]
    3
</pre>

<p>Tag names should begin with a letter (a-z, A-Z) or an underscore _. There
  is no checking performed on the existence of tag names. Attempting to access
  a field by a non-existent tag will result in a null <tt>[]</tt> being
  returned. Multiple occurrences of a tag name may occur in one vector. In this
  case, the value of the first tag encountered when scanning the vector from
  left to right is returned.</p>

<p>The primary use of tagged vectors is dynamic parameter passing. For
  instance, optional parameters can be achieved by concatenating an options and
  a defaults vector. Doing so allows the fields of the options vector to
  override those of the default.</p>

<h1><a id="SVLFunctions">SVL Functions</a></h1>

<p>SVL provides a rich set of built-in functions, such as trigonometric
  functions, random number generators, sampling, sorting, and permutation
  functions, as well as mathematical reduction functions. Syntactic shorthand
  notations are provided for common functions such as addition and
  multiplication. SVL functions (we speak here of <i>generic</i> SVL; a given
  application may have an additional set of built-in functions written in SVL)
  can be classified according to functionality. Loosely, functions fall under
  one or more of the following categories:</p>
  <ul>
    <li>
      <b>Operators</b>: extensions of scalar operators:
      <ul>
        <li>Unary: arithmetic functions, type conversions, logical properties,
        identities, random number generators</li>
        <li>Binary: arithmetic, logical, relational, and bitwise functions
          <ul>
            <li>Lexicographic</li>
            <li>Element-wise</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>
      <b>Structural Functions</b>: functions that deal with the ordering and
      value of elements:
      <ul>
        <li>Primary data access functions: <tt>get</tt>, <tt>peek</tt>,
        <tt>put</tt>, <tt>poke</tt></li>
        <li>m_-type and x_-type functions</li>
        <li>Functions that preserve the original ordering of elements</li>
        <li>Functions that preserve all original elements, but re-order
        them</li>
        <li>Re-shaping functions</li>
      </ul>
    </li>
    <li><b>I/O Functions</b>: sread, fread, write, swrite, fwrite, pr, print,
    file handling functions;</li>
    <li><b>Conversion Functions</b>: string, token, int, real, char</li>
    <li><b>Module and Task Management Functions</b>: load, script, fork,
    etc.</li>
    <li><b>Miscellaneous Functions</b>: igen, length, null, sleep, clock, quit,
    etc.</li>
  </ul>

<p>Functions take one and only one argument. A function argument is a vector.
  If a function requires multiple inputs, these will comprise the elements of
  the vector argument. Within the function definition, the argument values are
  assigned to variables local to the function. The process of doing this
  assignment is called <i>argument comprehension</i>. The elements of the
  argument vector need not all be assigned, and scalar elements up to the
  second level of nesting may be assigned. Beyond the second level of nesting,
  only entire sub-vectors can be assigned. If the vector passed to the function
  is of insufficient length or depth, nulls are assigned to the local
  variables.</p>

<p>Here is an example where the expected argument vector has five leaf-level
  elements, of which only four are assigned to local variables. Note that the
  argument vector may be of arbitrary shape.</p>

<pre>
    function some_func [ a, [] , [ b, [c,d] ] ]
        ...
    endfunction
</pre>

<p>If <tt>some_func</tt> is called as follows:</p>

<pre>
    some_func [ 1, 2, [ [3,4], [5,6] ] ]
</pre>

<p>then the local variable assignments are:</p>

<pre>
    a = 1;
    b = [3,4];
    c = 5;
    d = 6;
</pre>

<p>The brackets that you see enclosing the input argument in our
  illustrations of function calls, e.g. <tt>join [a,b]</tt>, are not a part of
  the function definition. This is in contrast, for instance, to C, where
  functions are signaled by parentheses, e.g. <tt>main( )</tt>. In most of the
  examples in this document, we have put a space between the function name and
  the function argument to emphasize this distinction. Observe that if we set
  <tt>v</tt>&nbsp;<tt>= [a,b]</tt>, then we can invoke <tt>join</tt> by typing
  <tt>join v</tt>. Using brackets here to enclose <tt>v</tt> would in fact
  result in a syntax error.</p>

<p><b>Note:</b> When calling a function without passing any arguments,
  <tt>[]</tt> must be provided as the function argument. Scalar arguments may,
  of course, be passed without brackets.</p>

<pre>
    svl&gt; neg 2 // scalar argument, call without brackets
      -2
    svl&gt; m = [ &quot;ab&quot;, [2,1] ]
    svl&gt; m[2] // careful! shorthand for get
      [ [2,1] ]
    svl&gt; m 2 // error!
</pre>

<p>The call <tt>m[2]</tt> is really shorthand for <tt>m[ [2] ]</tt>, which is
  shorthand for <tt>get</tt> <tt>[ m, [2] ]</tt>; observe that the argument
  (here <tt>2</tt>) is an index list, i.e. a vector.</p>

<p>For more on <tt>get</tt> see <a href="#PrimaryDataAccessFunctions">Primary
  Data Access Functions</a>.</p>

<h2><a id="FunctionExtension">Function
  Extension</a></h2>

<p>Some functions operate only at the top level of a vector. This is the
  case, for instance, of most structural functions and all lexicographic
  operators. These functions can be forced to descend one level of nesting
  using <i>function extension</i> or <i>apply-to-each</i>. The <tt>app</tt>
  function distributes a function over the top-level elements of a vector.</p>

<p>Here is an example of the behavior of an app'd function:</p>

<pre>
    svl&gt; reverse [ &quot;ab&quot;, &quot;cde&quot;, &quot;fghi&quot; ]
    [ &quot;fghi&quot;, &quot;cde&quot;, &quot;ab&quot; ]
    svl&gt; app reverse [ &quot;ab&quot;, &quot;cde&quot;, &quot;fghi&quot; ]
    [ &quot;ba&quot;, &quot;edc&quot;, &quot;ihgf&quot; ]
</pre>

<p>Observe how the applied-to-each function operates only on elements at the
  first level of nesting.</p>

<p>A special form of <tt>app</tt> is <tt>apt</tt>, short for <tt>app tr</tt>,
  where <tt>tr</tt> is the transpose function. <tt>apt</tt> first
  matrix-transposes the arguments to the function to be applied, and then
  app's the function. Here is an example:</p>

<pre>
    svl&gt; get [ [10,20,30], [1,2] ]
    [10,20]
    svl&gt; get [ [ [10,20,30], [40,50] ], [1,2] ]
    [ [10,20,30], [40,50] ]
    svl&gt; apt get [ [ [10,20,30], [40,50] ], [1,2] ]
    [10,50]
</pre>

<h2><a id="Operators">Operators</a></h2>

<p>A special kind of SVL function is the <i>operator</i>. SVL operators have
  both infix (traditional symbolic shorthand, such as <tt>+</tt> and
  <tt>&gt;</tt>) and prefix (the longhand SVL function name, such as
  <tt>add</tt>) notations. There are 2 kinds of operators:</p>
  <ul>
    <li>Unary operators (referred to as <i>unops</i>) operate on individual
    arguments, e.g. <tt>neg</tt>.</li>
    <li>Binary operators (referred to as <i>binops</i>) operate on two
    arguments at once e.g. <tt>add</tt>.</li>
  </ul>

<p>Some SVL operators are element-wise vector generalizations of scalar
  operators which can operate on vectors in addition to scalars. For example,
  add in SVL allows element-wise addition of 2 vectors, as well as addition
  with unit extension.</p>

<h2><a id="UnaryOperators">Unary Operators</a></h2>

<p>Unary operators operate at the leaf level of a vector. The result of
  applying an unop to a vector is a vector of the same shape as the input, with
  each scalar element transformed according to the applied operation. Here is
  an example:</p>

<pre>
    svl&gt; neg [1,2,3]
    [-1,-2,-3]
    svl&gt; neg [ 1, [2,3] ]
    [ -1, [-2,-3] ]
</pre>

<h2><a id="BinaryOperatorsAndReduction">Binary Operators and Reduction</a></h2>

<p>In general, when binary operators are called with 2 input vectors, the
  binary operation is applied to pairs of corresponding elements, one taken
  from each input vector. (One notable exception is lexicographic operators,
  which will be discussed in the next section; for now, we will not take them
  into consideration.) The 2 input vectors must be conformable, and the
  operations are performed on their leaves.</p>

<pre>
    svl&gt; pow [ [ 2, [3,4] ], [ 4, [2,3] ] ]
    [ 16, [9,64] ]
</pre>

<p>Some binary operators, however, can accept more than 2 arguments. The word
  &quot;argument&quot; refers to any of the top-level elements comprising the
  function's single argument vector. Arguments are said to be
  <i>reducible</i>. The arguments, which must be conformable, are combined
  through the successive applications of the operator <tt>op</tt> to each
  argument paired with the result of a previous application of <tt>op</tt>.
  (This is a conceptual explanation of what takes place; the SVL implementation
  is not necessarily sequential.) Such an operation implies that op be
  associative to guarantee that the result of a reduction be the same no matter
  how it is evaluated. Here are a few examples of arithmetic reduction:</p>

<pre>
    svl&gt; add [3,4,5]
    12
    svl&gt; add ( [2,3,4] * [5,6,7] ) // dot product
    56
    svl&gt; mul [3,4,5]
    60
    svl&gt; maxE [0,-1,4,3]
    4
    svl&gt; minE [0,-1,4,3]
    -1
</pre>

<p>Logical operators behave in the same manner:</p>

<pre>
    svl&gt; andE [1,1,0]
    0
    svl&gt; orE [1,1,0]
    1
    svl&gt; xorE [1,0,0]
    1
</pre>

<p>Relational operators reduce as follows:</p>

<pre>
    f [a,b,c,d] = andE [ f[a,b], f[b,c], f[c,d] ]
</pre>

<p>Hence, the following:</p>

<pre>
    svl&gt; ltE [-1,0,3,4]
    1
    svl&gt; ltE [1,0,3,4]
    0
</pre>

<h2><a id="LexicographicAndElementWiseOperators">Lexicographic and Element-wise
  Operators</a></h2>

<p>Relational and logical operators are classified into 2 types:
  <i>lexicographic</i> and <i>element-wise</i>. Only element-wise operators are
  considered binops, and only they reduce.</p>

<p>Relational operators are referred to as lexicographic if comparisons are
  made among only top-level elements, otherwise they are element-wise. In the
  former case, the operators are marked by the suffix <tt>L</tt>, in the
  latter, by the suffix <tt>E</tt>.</p>

<p>Comparisons are made based on ASCII value, which is, essentially,
  <i>dictionary order</i>, summarized in the following table:</p>
  <div align="center">
    <center>
      <table class="titlebar">
        <tr>
          <th>Object</th>
          <th>Placement</th>
        </tr>
        <tr>
          <td>Numbers (consecutive order)</td>
          <td>First</td>
        </tr>
        <tr>
          <td>Double-quoted characters<br />
          ASCII ordering:<br />
          Punctuation, A-Z, a-z</td>
          <td>Last</td>
        </tr>
        <tr>
          <td>Token data</td>
          <td>Unordered</td>
        </tr>
      </table>
    </center>
  </div>

<p>Here are a few illustrations of the difference in behavior between
  <tt>L</tt> and <tt>E</tt> operators. Note that element-wise operators require
  that their arguments be conformable, whereas lexicographic ones do not.</p>

<pre>
    svl&gt; [1,2] == [1,3]             // == shorthand for eqE
    [1,0]
    svl&gt; [1,2] === [1,3]            // === shorthand for eqL
    0
    svl&gt; minE [ [2,4], [1,3,5] ]    // error!
    svl&gt; minL [ [2,4], [1,3,5] ]
    [1,3,5]
    svl&gt; minE [ [&quot;c&quot;,&quot;d&quot;], [&quot;a&quot;,&quot;e&quot;] ]
    &quot;ad&quot;                            // equivalent to [&quot;a&quot;,&quot;d&quot;]
    svl&gt; minL [ [&quot;c&quot;,&quot;d&quot;], [&quot;a&quot;,&quot;e&quot;] ]
    &quot;ae&quot;                            // equivalent to [&quot;a&quot;,&quot;e&quot;]
</pre>

<h2><a id="StructuralFunctions">Structural
  Functions</a></h2>

<p>The umbrella term <i>structural functions</i> loosely groups together an
  assemblage of SVL functions that extract, insert and re-order vector elements
  without modifying the individual element values. The primary data access
  functions extract and insert elements according to an index list which
  specifies the elements to extract and insert. Data access can also be
  mediated by vector masks. Several functions can be invoked to generate both
  vector masks and index lists. Other functions make extractions according to
  element value rather than to position.</p>

<h2><a id="PrimaryDataAccessFunctions">Primary Data Access Functions</a></h2>

<p>There are four primary data access functions: <tt>get</tt> and
  <tt>peek</tt>, and their counterparts, <tt>put</tt> and <tt>poke</tt>.</p>

<p><tt>get</tt> extracts a sub-vector from amongst the top-level elements of
  the original input vector, whereas <tt>peek</tt> extracts only one element
  from the input vector, from any level of nesting. <tt>get</tt> leaves the
  extracted elements at the same level of nesting as in the source, while
  <tt>peek</tt> decreases their level of nesting.</p>

<p>Similarly, <tt>put</tt> replaces the top-level elements of a vector with
  the elements belonging to its argument vector, whereas <tt>poke</tt> replaces
  a single element at any level of nesting. <tt>put</tt> leaves the inserted
  elements at the same level of nesting as found in the source, while
  <tt>poke</tt> increases their level. Neither function changes the length of
  the vector. Note that <tt>put</tt> and <tt>poke</tt> do not actually alter
  the value of their source vectors; they merely return values without
  overwriting their sources.</p>

<p>Because the primary data functions are so frequently used, shorthand
  notations exist. <tt>get</tt> and <tt>put</tt> can be indicated by brackets
  <tt>[]</tt>, and <tt>peek</tt> and <tt>poke</tt> by parentheses.</p>

<p><b>Note:</b> The <tt>put</tt> and <tt>poke</tt> shorthand notations are
  not exactly equivalent to their longhand notations because they overwrite
  their source vectors with their return values. Thus, the shorthand notations
  include the assignment symbol <tt>=</tt>.</p>

<p>Remember that the order of parameters to <tt>put</tt> and <tt>get</tt> is
  the same as in their shorthand forms, i.e. destination, index, value.</p>

<pre>
    svl&gt; a = [ 1, [2,3], 4 ]
    svl&gt; a[2] // get
    [ [2,3] ]
    svl&gt; a(2) // peek
    [2,3]
    svl&gt; a[ [2,1] ] // get: elements 2 and 1
    [ [2,3], 1 ]
    svl&gt; a( [2,1] ) // peek: element 2's first element
    2
    svl&gt; a[ [2,1] ] = [ 5, 6 ]; a // put into elements 2 and 1
    [6,5,4]
    svl&gt; a = [ 1, [2,3], 4 ]
    svl&gt; a( [2,1] ) = [ 5, 6 ]; a // poke element 1 of element 2
    [ 1, [ [5,6], 3 ], 4 ]
    svl&gt; b = [2,3]; a( b(2) ) // index is an expression
    4
</pre>

<p>A summary of Primary Access Functions get and peek is as follows:</p>
<table class="titlebar">
  <tr>
    <th><b>Behavior</b></th>
    <th><tt>get</tt></th>
    <th><tt>peek</tt></th>
  </tr>
  <tr>
    <td>Extracts</td>
    <td>vector of elements</td>
    <td>one element</td>
  </tr>
  <tr>
    <td>Extracts from</td>
    <td>top level</td>
    <td>any level</td>
  </tr>
  <tr>
    <td>Extracted objects' level of nesting</td>
    <td>same</td>
    <td>decreased</td>
  </tr>
</table>

<p>A summary of primary access functions, <tt>put</tt> and <tt>poke</tt>,
  follows:</p>
<table class="titlebar">
  <tr>
    <th><b>Behavior</b></th>
    <th><tt>put</tt></th>
    <th><tt>poke</tt></th>
  </tr>
  <tr>
    <td>Replaces</td>
    <td>several elements</td>
    <td>one element</td>
  </tr>
  <tr>
    <td>Inserts at</td>
    <td>top level</td>
    <td>any level</td>
  </tr>
  <tr>
    <td>Inserted objects' level of nesting</td>
    <td>same</td>
    <td>increased</td>
  </tr>
</table>

<p>Recall that it is possible to index beyond the end of a vector. This
  implies that we can extract and insert elements beyond the end of a
  vector:</p>

<pre class="code">
svl&gt; a = igen 5; a
[1,2,3,4,5]
svl&gt; a(0) // error! can't access this end
svl&gt; a(6) // peek returns null (not displayed)
svl&gt; a[6] // get
[ [] ]
svl&gt; a(7) = [6,7] // poke
svl&gt; a[8] = [ [8,9] ]; a // put
[ 1, 2, 3, 4, 5, [] , [6,7], [8,9] ]
</pre>

<p><tt>get</tt> and <tt>put</tt> have masked variants which use masks instead
  of index lists to specify which elements to access. See the next section for
  more on masking and indexing.</p>

<h2><a id="m_-typeAndx_-typeFunctions">m_-type and x_-type Functions</a></h2>

<p>SVL vector elements can be specified by their position in a vector using
  either an index list or a mask. Both index lists and masks are flat numeric
  vectors. There are two conspicuous differences between an index list and a
  mask. Firstly, an index list is a list of positions, and thus can be
  arbitrarily long or short, and may contain duplicates. A mask, however, is
  composed of zero and non-zero values, the non-zero values marking selected
  elements. Thus, a mask must match its corresponding vector exactly in length,
  except if there is a possibility of unit-extension. Secondly, an index list
  may be used to specify elements at deeper levels of nesting, for instance,
  when used with <tt>peek</tt> or <tt>poke</tt>. A mask, however, is applied to
  only the top level of a vector.</p>

<p>SVL functions that involve masks or index lists have a naming convention
  that makes this association explicit. The prefix <tt>m_</tt> is used to mark
  a function that returns a mask, and the prefix <tt>x_</tt> to mark one that
  returns an index list. Note that <tt>get</tt> and <tt>put</tt> have
  <tt>m</tt> forms, i.e. without an underscore. They <i>use</i> rather than
  <i>return</i> masks or index lists, and they do not have an <tt>x_</tt> form
  (because in their basic form, <tt>get</tt> and <tt>put</tt> use index lists).
  Similarly, <tt>smear</tt> has an <tt>m</tt> form, not <tt>m_</tt>, as it also
  uses rather than returns a mask.</p>

<p>SVL functions have the following relationship with their indexed and
  masked variants:</p>

<pre class="code">
get [ v, x_op v ] = op v
OR
get [ v, x_op [v,w] ] = op [v,w]

v | m_op v = op v
OR
v | m_op [v,w] = op [v,w]
</pre>

<p>Note that the functions <tt>x_minE</tt>, <tt>x_minL</tt>, <tt>x_maxE</tt>,
  and <tt>x_maxL</tt> are associated with <tt>peek</tt> rather than with
  <tt>get</tt>:</p>

<pre class="code">
peek [ v, x_minE/L v ] = minE/L v
peek [ v, x_maxE/L v ] = maxE/L v
</pre>

<h2><a id="ClassificationOfStructuralFunctions">Classification of Structural
  Functions</a></h2>

<p>The myriad SVL structural functions can be classified according to whether
  or not they preserve the source order of elements, whether or not they keep
  all source elements, and whether they maintain or alter the shape of the
  source vector. Functions that select elements conditioned on their value
  generally preserve the order of the elements as found in the source. Pure
  re-ordering functions preserve all the original elements. Reshaping functions
  keep all the original elements of the source, but may replicate some of them,
  or split them off into separate vectors. For more on structural functions,
  consult the function reference.</p>

<h1><a id="HowCLICommandsAreExecuted">How
  CLI Commands Are Executed</a></h1>

<p>Command-line interpreter commands input by the user are packaged and
  compiled into modules by the interpreter, and then run. Semi-colons are
  supplied, if necessary. Because each line becomes a <i>module</i> (an
  executable block of vector binary code), multi-line statements are forbidden.
  Thus, loops can only be used if their scope is confined to one line, and
  function definitions exist only on the line upon which they have been
  declared.</p>

<p>Functions cannot contain &quot;do nothing&quot; (history-insensitive)
  statements, that is, statements that contain neither assignments, nor
  function calls involving random numbers, nor <tt>print</tt> statements. Such
  expressions are legal when entered at the command line, however, for they are
  made into <tt>print</tt> statements; this is why their return values are
  echoed back to the display.</p>

<p>For more information on modules see <a class="svl" href=
  "funcs.htm">modules</a>. For more information on declaring variables at the
  command line see <a href="funcs.htm">Variables and Functions at the
  CLI</a>.</p>

<h1><a id="Built-inConstants">Built-in
  Constants</a></h1>

<p>SVL has a set of pre-defined constants that give the numerical limits of
  your machine. These constants are given in the following table:</p>
  <table class="noborder">
    <tr>
      <td>REAL_MIN</td>
      <td>minimum positive floating-point number; under IEEE standard, smaller
      positive numbers can be created, but at the expense of precision</td>
    </tr>
    <tr>
      <td>REAL_MAX</td>
      <td>maximum positive floating-point number</td>
    </tr>
    <tr>
      <td>REAL_BITS</td>
      <td>number of bits in the mantissa of a floating-point number</td>
    </tr>
    <tr>
      <td>INT_MIN</td>
      <td>maximum negative integer</td>
    </tr>
    <tr>
      <td>INT_MAX</td>
      <td>maximum positive integer</td>
    </tr>
    <tr>
      <td>EPS_M</td>
      <td>machine epsilon: floating-point precision</td>
    </tr>
    <tr>
      <td>REAL_IEEE</td>
      <td>1 if IEEE standard used, 0 otherwise</td>
    </tr>
    <tr>
      <td>REAL_MAXEXP</td>
      <td>maximum exponent for positive numbers in e-notation</td>
    </tr>
    <tr>
      <td>REAL_MINEXP</td>
      <td>minimum exponent for normalized positive numbers in e-notation; under
      IEEE standard, the exponent may be further reduced, but at the expense of
      precision</td>
    </tr>
    <tr>
      <td>REAL_DIGITS</td>
      <td>number of significant bits in a floating-point number</td>
    </tr>
    <tr>
      <td>REAL_INF</td>
      <td>positive infinity (1/0)</td>
    </tr>
    <tr>
      <td>INT_BITS</td>
      <td>number of bits (including sign bit) in an integer</td>
    </tr>
  </table>
  <p class="caption">SVL Built-In Constants</p>


<p>Next: <a href="data.htm">SVL Expressions</a></p>

<p><a href="../../fcnindex.htm">Function Index</a></p>
  <!-- START MOE_FOOTER -->
  <div class="MOE_FOOTER">
    <img src="../../images/ccgicon.png" /> <a href="../../index.htm"></a>
<a href="../../legal.htm"></a> &copy;<span class="versionyear"></span>
    <a href="http://www.chemcomp.com"></a>. All rights reserved.<br />
    <a href="mailto:info@chemcomp.com"></a>
  </div><!-- END MOE_FOOTER -->
</div>
</div>
</body>
</html>

